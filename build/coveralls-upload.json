{"repo_token":"BCkEcrsYstgmZd7v5btNZB6GlxoTtRSuc","git":{"branch":"master","head":{"id":"21d23700cb1e505a3bdb4d351ab0b131aa5fe418","author_name":"Adrian Pop","author_email":"contact@adrianpop.com","committer_name":"Adrian Pop","committer_email":"contact@adrianpop.com","message":"Managed to make Slack to work"},"remotes":[{"name":"origin","url":"https:\/\/github.com\/AdrianPop\/sense.git"}]},"run_at":"2015-09-03 08:14:31 +0000","source_files":[{"name":"sense\/Container.php","source":"<?php namespace sense;\n\nclass Container\n{\n    private static $_instance = null;\n    \n    private $_data = array();\n    \n    private function __construct() {}\n    \n    public static function getInstance()\n    {\n        return is_null(self::$_instance) ? (self::$_instance = new self) : self::$_instance;\n    }\n    \n    public function __get($name)\n    {\n        $instance = self::getInstance();\n        \n        if ( isset($instance->_data[$name]) )\n        {\n            return $instance->_data[$name];\n        }\n        \n        return null;\n    }\n    \n    public function set($name, $value)\n    {\n        return self::getInstance()->_data[$name] = $value;\n    }\n}\n\nclass C extends Container {}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,5,null,null,null,null,3,null,3,3,3,null,null,0,null,null,null,null,3,null,null,null,null]},{"name":"sense\/Sense.php","source":"<?php namespace sense;\n\nuse Monolog\\Logger;\nuse sense\\C;\nuse sense\\net\\Request;\nuse sense\\net\\Response;\nuse sense\\net\\Router;\n\n\n\/**\n * Class Sense\n * @package sense\n *\/\nclass Sense\n{\n    public $instance;\n\n    \/**\n     * @var Container\n     *\/\n    private $container;\n\n    public function __construct(Container $container)\n    {\n        $this->container = $container;\n    }\n\n    \/**\n     * @return Container\n     *\/\n    public function getContainer()\n    {\n        return $this->container;\n    }\n\n    \/**\n     * Load require dependencies\n     *\n     * @return $this\n     *\/\n    public function loadDependencies()\n    {\n        $this->container->set('request', new Request());\n        $this->container->set('response', new Response());\n        $this->container->set('router', new Router($this->container));\n\n        return $this;\n    }\n\n    \/**\n     * Load routes and compile them to Pux\n     *\n     * @return $this\n     *\/\n    public function loadRouting()\n    {\n        $routes = require_once dirname(__FILE__) . \"\/..\/app\/routes.php\";\n\n        $this->getContainer()->router->attachRoutes($routes);\n\n        return $this;\n    }\n\n    public function injectLoader(Logger $logger)\n    {\n        $this->container->set('logger', $logger);\n\n        return $this;\n    }\n\n    \/**\n     * Run\n     * @return bool\n     *\/\n    public function run()\n    {\n        return $this->container->router->dispatchAndRespond();\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,4,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,3,3,3,null,3,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,0,null,null]},{"name":"sense\/net\/Request.php","source":"<?php namespace sense\\net;\n\nuse \\Zend\\Http\\PhpEnvironment\\Request as HttpRequest;\n\nclass Request extends HttpRequest\n{\n    \n}","coverage":[null,null,null,null,null,null,null,null]},{"name":"sense\/net\/Response.php","source":"<?php namespace sense\\net;\n\nuse \\Zend\\Http\\PhpEnvironment\\Response as HttpResponse;\n\nclass Response extends HttpResponse\n{\n    \n}","coverage":[null,null,null,null,null,null,null,null]},{"name":"sense\/net\/Route.php","source":"<?php namespace sense\\net;\n\nclass Route\n{\n    public $method;\n    \n    public $uriPath;\n    \n    public $callable;\n    \n    public $requires;\n    \n    public $defaults;\n    \n    public function __construct($method, $uriPath, $callable, $requires = [], $defaults = [])\n    {\n        $this->method = explode(',', $method);\n        \n        $this->uriPath = $uriPath;\n        \n        $this->callable = is_object($callable) ? $callable : explode('@', $callable);\n        \n        $this->requires = $requires;\n        \n        $this->defaults = $defaults;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,null,3,null,3,null,3,3,null]},{"name":"sense\/net\/Router.php","source":"<?php namespace sense\\net;\n\nuse \\Pux\\Mux as PuxMux;\nuse sense\\Container;\n\nclass Router extends PuxMux\n{\n    \/**\n     * @var Container\n     *\/\n    private $container = null;\n\n    public function __construct($container)\n    {\n        $this->container = $container;\n    }\n\n    public function attachRoutes($routes)\n    {\n        foreach ( $routes as $route )\n        {\n            $this->create($route);\n        }\n    }\n\n    private function create(Route $route)\n    {\n        foreach ( $route->method as $method )\n        {\n            $this->{$method}($route->uriPath, $route->callable,\n                [\n                    'require' => $route->requires,\n                    'default' => $route->defaults\n                ]\n            );\n        }\n    }\n\n    \/**\n     * Should be moved to Response\n     *\n     * @return mixed\n     * @throws \\Exception\n     *\/\n    public function dispatchAndRespond()\n    {\n        $response = $this->container->response;\n\n        $request = $this->container->request;\n\n        $route = $this->dispatch($request->getRequestUri());\n\n        if (is_null($route))\n        {\n            $response->setStatusCode(Response::STATUS_CODE_404)\n                ->setContent('404 Not Found!');\n\n            return $response->send();\n        }\n\n        $response->setContent(\\Pux\\Executor::execute($route));\n        return $response->send();\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,3,null,null,null,3,null,3,3,3,null,null,null,3,null,3,null,3,3,3,3,3,3,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,0,0,0,0,null,0,null,null,0,0,null,null]},{"name":"vendor\/composer\/ClassLoader.php","source":"<?php\n\n\/*\n * This file is part of Composer.\n *\n * (c) Nils Adermann <naderman@naderman.de>\n *     Jordi Boggiano <j.boggiano@seld.be>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Composer\\Autoload;\n\n\/**\n * ClassLoader implements a PSR-0 class loader\n *\n * See https:\/\/github.com\/php-fig\/fig-standards\/blob\/master\/accepted\/PSR-0.md\n *\n *     $loader = new \\Composer\\Autoload\\ClassLoader();\n *\n *     \/\/ register classes with namespaces\n *     $loader->add('Symfony\\Component', __DIR__.'\/component');\n *     $loader->add('Symfony',           __DIR__.'\/framework');\n *\n *     \/\/ activate the autoloader\n *     $loader->register();\n *\n *     \/\/ to enable searching the include path (eg. for PEAR packages)\n *     $loader->setUseIncludePath(true);\n *\n * In this example, if you try to use a class in the Symfony\\Component\n * namespace or one of its children (Symfony\\Component\\Console for instance),\n * the autoloader will first look for the class under the component\/\n * directory, and it will then fallback to the framework\/ directory if not\n * found before giving up.\n *\n * This class is loosely based on the Symfony UniversalClassLoader.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Jordi Boggiano <j.boggiano@seld.be>\n *\/\nclass ClassLoader\n{\n    \/\/ PSR-4\n    private $prefixLengthsPsr4 = array();\n    private $prefixDirsPsr4 = array();\n    private $fallbackDirsPsr4 = array();\n\n    \/\/ PSR-0\n    private $prefixesPsr0 = array();\n    private $fallbackDirsPsr0 = array();\n\n    private $useIncludePath = false;\n    private $classMap = array();\n\n    private $classMapAuthoritative = false;\n\n    public function getPrefixes()\n    {\n        if (!empty($this->prefixesPsr0)) {\n            return call_user_func_array('array_merge', $this->prefixesPsr0);\n        }\n\n        return array();\n    }\n\n    public function getPrefixesPsr4()\n    {\n        return $this->prefixDirsPsr4;\n    }\n\n    public function getFallbackDirs()\n    {\n        return $this->fallbackDirsPsr0;\n    }\n\n    public function getFallbackDirsPsr4()\n    {\n        return $this->fallbackDirsPsr4;\n    }\n\n    public function getClassMap()\n    {\n        return $this->classMap;\n    }\n\n    \/**\n     * @param array $classMap Class to filename map\n     *\/\n    public function addClassMap(array $classMap)\n    {\n        if ($this->classMap) {\n            $this->classMap = array_merge($this->classMap, $classMap);\n        } else {\n            $this->classMap = $classMap;\n        }\n    }\n\n    \/**\n     * Registers a set of PSR-0 directories for a given prefix, either\n     * appending or prepending to the ones previously set for this prefix.\n     *\n     * @param string       $prefix  The prefix\n     * @param array|string $paths   The PSR-0 root directories\n     * @param bool         $prepend Whether to prepend the directories\n     *\/\n    public function add($prefix, $paths, $prepend = false)\n    {\n        if (!$prefix) {\n            if ($prepend) {\n                $this->fallbackDirsPsr0 = array_merge(\n                    (array) $paths,\n                    $this->fallbackDirsPsr0\n                );\n            } else {\n                $this->fallbackDirsPsr0 = array_merge(\n                    $this->fallbackDirsPsr0,\n                    (array) $paths\n                );\n            }\n\n            return;\n        }\n\n        $first = $prefix[0];\n        if (!isset($this->prefixesPsr0[$first][$prefix])) {\n            $this->prefixesPsr0[$first][$prefix] = (array) $paths;\n\n            return;\n        }\n        if ($prepend) {\n            $this->prefixesPsr0[$first][$prefix] = array_merge(\n                (array) $paths,\n                $this->prefixesPsr0[$first][$prefix]\n            );\n        } else {\n            $this->prefixesPsr0[$first][$prefix] = array_merge(\n                $this->prefixesPsr0[$first][$prefix],\n                (array) $paths\n            );\n        }\n    }\n\n    \/**\n     * Registers a set of PSR-4 directories for a given namespace, either\n     * appending or prepending to the ones previously set for this namespace.\n     *\n     * @param string       $prefix  The prefix\/namespace, with trailing '\\\\'\n     * @param array|string $paths   The PSR-0 base directories\n     * @param bool         $prepend Whether to prepend the directories\n     *\n     * @throws \\InvalidArgumentException\n     *\/\n    public function addPsr4($prefix, $paths, $prepend = false)\n    {\n        if (!$prefix) {\n            \/\/ Register directories for the root namespace.\n            if ($prepend) {\n                $this->fallbackDirsPsr4 = array_merge(\n                    (array) $paths,\n                    $this->fallbackDirsPsr4\n                );\n            } else {\n                $this->fallbackDirsPsr4 = array_merge(\n                    $this->fallbackDirsPsr4,\n                    (array) $paths\n                );\n            }\n        } elseif (!isset($this->prefixDirsPsr4[$prefix])) {\n            \/\/ Register directories for a new namespace.\n            $length = strlen($prefix);\n            if ('\\\\' !== $prefix[$length - 1]) {\n                throw new \\InvalidArgumentException(\"A non-empty PSR-4 prefix must end with a namespace separator.\");\n            }\n            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;\n            $this->prefixDirsPsr4[$prefix] = (array) $paths;\n        } elseif ($prepend) {\n            \/\/ Prepend directories for an already registered namespace.\n            $this->prefixDirsPsr4[$prefix] = array_merge(\n                (array) $paths,\n                $this->prefixDirsPsr4[$prefix]\n            );\n        } else {\n            \/\/ Append directories for an already registered namespace.\n            $this->prefixDirsPsr4[$prefix] = array_merge(\n                $this->prefixDirsPsr4[$prefix],\n                (array) $paths\n            );\n        }\n    }\n\n    \/**\n     * Registers a set of PSR-0 directories for a given prefix,\n     * replacing any others previously set for this prefix.\n     *\n     * @param string       $prefix The prefix\n     * @param array|string $paths  The PSR-0 base directories\n     *\/\n    public function set($prefix, $paths)\n    {\n        if (!$prefix) {\n            $this->fallbackDirsPsr0 = (array) $paths;\n        } else {\n            $this->prefixesPsr0[$prefix[0]][$prefix] = (array) $paths;\n        }\n    }\n\n    \/**\n     * Registers a set of PSR-4 directories for a given namespace,\n     * replacing any others previously set for this namespace.\n     *\n     * @param string       $prefix The prefix\/namespace, with trailing '\\\\'\n     * @param array|string $paths  The PSR-4 base directories\n     *\n     * @throws \\InvalidArgumentException\n     *\/\n    public function setPsr4($prefix, $paths)\n    {\n        if (!$prefix) {\n            $this->fallbackDirsPsr4 = (array) $paths;\n        } else {\n            $length = strlen($prefix);\n            if ('\\\\' !== $prefix[$length - 1]) {\n                throw new \\InvalidArgumentException(\"A non-empty PSR-4 prefix must end with a namespace separator.\");\n            }\n            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;\n            $this->prefixDirsPsr4[$prefix] = (array) $paths;\n        }\n    }\n\n    \/**\n     * Turns on searching the include path for class files.\n     *\n     * @param bool $useIncludePath\n     *\/\n    public function setUseIncludePath($useIncludePath)\n    {\n        $this->useIncludePath = $useIncludePath;\n    }\n\n    \/**\n     * Can be used to check if the autoloader uses the include path to check\n     * for classes.\n     *\n     * @return bool\n     *\/\n    public function getUseIncludePath()\n    {\n        return $this->useIncludePath;\n    }\n\n    \/**\n     * Turns off searching the prefix and fallback directories for classes\n     * that have not been registered with the class map.\n     *\n     * @param bool $classMapAuthoritative\n     *\/\n    public function setClassMapAuthoritative($classMapAuthoritative)\n    {\n        $this->classMapAuthoritative = $classMapAuthoritative;\n    }\n\n    \/**\n     * Should class lookup fail if not found in the current class map?\n     *\n     * @return bool\n     *\/\n    public function isClassMapAuthoritative()\n    {\n        return $this->classMapAuthoritative;\n    }\n\n    \/**\n     * Registers this instance as an autoloader.\n     *\n     * @param bool $prepend Whether to prepend the autoloader or not\n     *\/\n    public function register($prepend = false)\n    {\n        spl_autoload_register(array($this, 'loadClass'), true, $prepend);\n    }\n\n    \/**\n     * Unregisters this instance as an autoloader.\n     *\/\n    public function unregister()\n    {\n        spl_autoload_unregister(array($this, 'loadClass'));\n    }\n\n    \/**\n     * Loads the given class or interface.\n     *\n     * @param  string    $class The name of the class\n     * @return bool|null True if loaded, null otherwise\n     *\/\n    public function loadClass($class)\n    {\n        if ($file = $this->findFile($class)) {\n            includeFile($file);\n\n            return true;\n        }\n    }\n\n    \/**\n     * Finds the path to the file where the class is defined.\n     *\n     * @param string $class The name of the class\n     *\n     * @return string|false The path if found, false otherwise\n     *\/\n    public function findFile($class)\n    {\n        \/\/ work around for PHP 5.3.0 - 5.3.2 https:\/\/bugs.php.net\/50731\n        if ('\\\\' == $class[0]) {\n            $class = substr($class, 1);\n        }\n\n        \/\/ class map lookup\n        if (isset($this->classMap[$class])) {\n            return $this->classMap[$class];\n        }\n        if ($this->classMapAuthoritative) {\n            return false;\n        }\n\n        $file = $this->findFileWithExtension($class, '.php');\n\n        \/\/ Search for Hack files if we are running on HHVM\n        if ($file === null && defined('HHVM_VERSION')) {\n            $file = $this->findFileWithExtension($class, '.hh');\n        }\n\n        if ($file === null) {\n            \/\/ Remember that this class does not exist.\n            return $this->classMap[$class] = false;\n        }\n\n        return $file;\n    }\n\n    private function findFileWithExtension($class, $ext)\n    {\n        \/\/ PSR-4 lookup\n        $logicalPathPsr4 = strtr($class, '\\\\', DIRECTORY_SEPARATOR) . $ext;\n\n        $first = $class[0];\n        if (isset($this->prefixLengthsPsr4[$first])) {\n            foreach ($this->prefixLengthsPsr4[$first] as $prefix => $length) {\n                if (0 === strpos($class, $prefix)) {\n                    foreach ($this->prefixDirsPsr4[$prefix] as $dir) {\n                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $length))) {\n                            return $file;\n                        }\n                    }\n                }\n            }\n        }\n\n        \/\/ PSR-4 fallback dirs\n        foreach ($this->fallbackDirsPsr4 as $dir) {\n            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {\n                return $file;\n            }\n        }\n\n        \/\/ PSR-0 lookup\n        if (false !== $pos = strrpos($class, '\\\\')) {\n            \/\/ namespaced class name\n            $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1)\n                . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);\n        } else {\n            \/\/ PEAR-like class name\n            $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;\n        }\n\n        if (isset($this->prefixesPsr0[$first])) {\n            foreach ($this->prefixesPsr0[$first] as $prefix => $dirs) {\n                if (0 === strpos($class, $prefix)) {\n                    foreach ($dirs as $dir) {\n                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {\n                            return $file;\n                        }\n                    }\n                }\n            }\n        }\n\n        \/\/ PSR-0 fallback dirs\n        foreach ($this->fallbackDirsPsr0 as $dir) {\n            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {\n                return $file;\n            }\n        }\n\n        \/\/ PSR-0 include paths.\n        if ($this->useIncludePath && $file = stream_resolve_include_path($logicalPathPsr0)) {\n            return $file;\n        }\n    }\n}\n\n\/**\n * Scope isolated include.\n *\n * Prevents access to $this\/self from included files.\n *\/\nfunction includeFile($file)\n{\n    include $file;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,null,null,null,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,0,0,0,null,0,null,null,0,null,null,0,0,0,null,0,null,0,0,0,0,0,0,0,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,0,0,0,0,0,0,null,0,null,0,null,0,0,0,null,0,0,0,null,0,0,0,0,0,null,0,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,0,0,null,0,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,5,5,null,5,null,0,null,null,null,null,null,null,null,null,null,null,null,5,0,0,null,null,5,5,null,3,0,null,null,3,null,null,3,0,0,null,3,null,0,null,null,3,null,null,null,null,null,3,null,3,3,3,3,3,3,3,null,0,0,2,0,null,null,0,0,0,null,0,null,null,0,null,0,0,0,null,0,null,null,0,0,0,0,0,0,null,0,0,0,0,null,null,0,0,0,null,0,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,5,5]},{"name":"vendor\/composer\/autoload_real.php","source":"<?php\n\n\/\/ autoload_real.php @generated by Composer\n\nclass ComposerAutoloaderInit4094a5b0d77e48dfa898cd04c1dc4670\n{\n    private static $loader;\n\n    public static function loadClassLoader($class)\n    {\n        if ('Composer\\Autoload\\ClassLoader' === $class) {\n            require __DIR__ . '\/ClassLoader.php';\n        }\n    }\n\n    public static function getLoader()\n    {\n        if (null !== self::$loader) {\n            return self::$loader;\n        }\n\n        spl_autoload_register(array('ComposerAutoloaderInit4094a5b0d77e48dfa898cd04c1dc4670', 'loadClassLoader'), true, true);\n        self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader();\n        spl_autoload_unregister(array('ComposerAutoloaderInit4094a5b0d77e48dfa898cd04c1dc4670', 'loadClassLoader'));\n\n        $map = require __DIR__ . '\/autoload_namespaces.php';\n        foreach ($map as $namespace => $path) {\n            $loader->set($namespace, $path);\n        }\n\n        $map = require __DIR__ . '\/autoload_psr4.php';\n        foreach ($map as $namespace => $path) {\n            $loader->setPsr4($namespace, $path);\n        }\n\n        $classMap = require __DIR__ . '\/autoload_classmap.php';\n        if ($classMap) {\n            $loader->addClassMap($classMap);\n        }\n\n        $loader->register(true);\n\n        return $loader;\n    }\n}\n\nfunction composerRequire4094a5b0d77e48dfa898cd04c1dc4670($file)\n{\n    require $file;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,null,0,0,null,null,0,0,0,null,0,0,0,0,null,0,0,0,0,null,0,0,0,0,null,0,null,0,null,null,null,null,null,0,0]},{"name":"vendor\/corneltek\/pux\/src\/Pux\/Mux.php","source":"<?php\n\/\/ vim:et:sw=4:ts=4:sts=4:\nnamespace Pux;\nuse Pux\\PatternCompiler;\nuse Pux\\Controller;\nuse Exception;\n\ndefine('REQUEST_METHOD_GET', 1);\ndefine('REQUEST_METHOD_POST', 2);\ndefine('REQUEST_METHOD_PUT', 3);\ndefine('REQUEST_METHOD_DELETE', 4);\ndefine('REQUEST_METHOD_PATCH', 5);\ndefine('REQUEST_METHOD_HEAD', 6);\ndefine('REQUEST_METHOD_OPTIONS', 7);\n\nclass Mux\n{\n    public $routes = array();\n\n    public $staticRoutes = array();\n\n    public $routesById = array();\n\n\n    \/**\n     * @var Mux[id]\n     *\/\n    public $submux = array();\n\n    public $id;\n\n\n    \/**\n     * @var boolean expand routes to parent mux.\n     *\n     * When expand is enabled, all mounted Mux will expand the routes to the parent mux.\n     * This improves the dispatch performance when you have a lot of sub mux to dispatch.\n     *\n     * When expand is enabled, the pattern comparison strategy for\n     * strings will match the full string.\n     *\n     * When expand is disabled, the pattern comparison strategy for\n     * strings will match the prefix.\n     *\/\n    public $expand = true;\n\n    public static $id_counter = 0;\n\n\n    public static function generate_id() {\n        return ++static::$id_counter;\n    }\n\n    public function getId() {\n        if ( $this->id ) {\n            return $this->id;\n        }\n        return $this->id = self::generate_id();\n    }\n\n    public function appendRoute($pattern, $callback, array $options = array())\n    {\n        $this->routes[] = array( false, $pattern, $callback, $options );\n    }\n\n    public function appendPCRERoute(array $routeArgs, $callback)\n    {\n        $this->routes[] = array(\n            true, \/\/ PCRE\n            $routeArgs['compiled'],\n            $callback,\n            $routeArgs,\n        );\n    }\n\n    public function mount($pattern, $mux, array $options = array())\n    {\n        if ($mux instanceof Controller) {\n            $mux = $mux->expand();\n        } else if ((!is_object($mux) || !($mux instanceof Mux)) && is_callable($mux)) {\n            $mux($mux = new Mux());\n        }\n\n        if ($this->expand) {\n            $pcre = strpos($pattern,':') !== false;\n\n            \/\/ rewrite submux routes\n            foreach ($mux->routes as $route) {\n                \/\/ process for pcre\n                if ( $route[0] || $pcre ) {\n                    $newPattern = $pattern . ( $route[0] ? $route[3]['pattern'] : $route[1] );\n                    $routeArgs = PatternCompiler::compile($newPattern, \n                        array_replace_recursive($options, $route[3]) );\n                    $this->appendPCRERoute( $routeArgs, $route[2] );\n                } else {\n                    $this->routes[] = array(\n                        false,\n                        $pattern . $route[1],\n                        $route[2],\n                        isset($route[3]) ? array_replace_recursive($options, $route[3]) : $options,\n                    );\n                }\n            }\n        } else {\n            $muxId = $mux->getId();\n            $this->add($pattern, $muxId, $options);\n            $this->submux[ $muxId ] = $mux;\n        }\n    }\n\n    public function delete($pattern, $callback, array $options = array())\n    {\n        $options['method'] = REQUEST_METHOD_DELETE;\n        $this->add($pattern, $callback, $options);\n    }\n\n    public function put($pattern, $callback, array $options = array())\n    {\n        $options['method'] = REQUEST_METHOD_PUT;\n        $this->add($pattern, $callback, $options);\n    }\n\n    public function get($pattern, $callback, array $options = array())\n    {\n        $options['method'] = REQUEST_METHOD_GET;\n        $this->add($pattern, $callback, $options);\n    }\n\n    public function post($pattern, $callback, array $options = array())\n    {\n        $options['method'] = REQUEST_METHOD_POST;\n        $this->add($pattern, $callback, $options);\n    }\n\n    public function patch($pattern, $callback, array $options = array())\n    {\n        $options['method'] = REQUEST_METHOD_PATCH;\n        $this->add($pattern, $callback, $options);\n    }\n\n\n    public function head($pattern, $callback, array $options = array())\n    {\n        $options['method'] = REQUEST_METHOD_HEAD;\n        $this->add($pattern, $callback, $options);\n    }\n\n\n    public function options($pattern, $callback, array $options = array())\n    {\n        $options['method'] = REQUEST_METHOD_OPTIONS;\n        $this->add($pattern, $callback, $options);\n    }\n\n    public function any($pattern, $callback, array $options = array())\n    {\n        $this->add($pattern, $callback, $options);\n    }\n\n    public function add($pattern, $callback, array $options = array())\n    {\n        if ( is_string($callback) && strpos($callback,':') !== false ) {\n            $callback = explode(':', $callback);\n        }\n\n        \/\/ compile place holder to patterns\n        $pcre = strpos($pattern,':') !== false;\n        if ( $pcre ) {\n            $routeArgs = PatternCompiler::compile($pattern, $options);\n\n            \/\/ generate a pcre pattern route\n            $route = array( \n                true, \/\/ PCRE\n                $routeArgs['compiled'],\n                $callback,\n                $routeArgs,\n            );\n            if ( isset($options['id']) ) {\n                $this->routesById[ $options['id'] ] = $route;\n            }\n            return $this->routes[] = $route;\n        } else {\n            $route = array(\n                false,\n                $pattern,\n                $callback,\n                $options,\n            );\n            if ( isset($options['id']) ) {\n                $this->routesById[ $options['id'] ] = $route;\n            }\n            \/\/ generate a simple string route.\n            return $this->routes[] = $route;\n        }\n    }\n\n    public function getRoute($id) {\n        if ( isset($this->routesById[$id]) ) {\n            return $this->routesById[$id];\n        }\n\n    }\n\n    public function sort()\n    {\n        usort($this->routes, array('Pux\\\\MuxCompiler','sort_routes'));\n    }\n\n    static public function sort_routes($a, $b)\n    {\n        if ( $a[0] && $b[0] ) {\n            return strlen($a[3]['compiled']) > strlen($b[3]['compiled']);\n        } elseif ( $a[0] ) {\n            return 1;\n        } elseif ( $b[0] ) {\n            return -1;\n        }\n        if ( strlen($a[1]) > strlen($b[1]) ) {\n            return 1;\n        } elseif ( strlen($a[1]) == strlen($b[1]) ) {\n            return 0;\n        } else {\n            return -1;\n        }\n    }\n\n\n    public function compile($outFile, $sortBeforeCompile = true)\n    {\n        \/\/ compile routes to php file as a cache.\n        if ($sortBeforeCompile) {\n            $this->sort();\n        }\n\n        $code = '<?php return ' . $this->export() . ';';\n        return file_put_contents($outFile, $code);\n    }\n\n    public function getSubMux($id)\n    {\n        if ( isset($this->submux[ $id ] ) ) {\n            return $this->submux[ $id ];\n        }\n    }\n\n    public static function getRequestMethodConstant($method)\n    {\n        switch (strtoupper($method)) {\n            case \"POST\":\n                return REQUEST_METHOD_POST;\n            case \"GET\":\n                return REQUEST_METHOD_GET;\n            case \"PUT\":\n                return REQUEST_METHOD_PUT;\n            case \"DELETE\":\n                return REQUEST_METHOD_DELETE;\n            case \"PATCH\":\n                return REQUEST_METHOD_PATCH;\n            case \"HEAD\":\n                return REQUEST_METHOD_HEAD;\n            case \"OPTIONS\":\n                return REQUEST_METHOD_OPTIONS;\n            default:\n                return 0;\n        }\n    }\n\n    public function match($path)\n    {\n        $requestMethod = null;\n\n        if (isset($_SERVER['HTTP_X_HTTP_METHOD_OVERRIDE'])) {\n            $requestMethod = self::getRequestMethodConstant($_SERVER['HTTP_X_HTTP_METHOD_OVERRIDE']);\n        } else if (isset($_SERVER['REQUEST_METHOD'])) {\n            $requestMethod = self::getRequestMethodConstant($_SERVER['REQUEST_METHOD']);\n        }\n\n        foreach( $this->routes as $route ) {\n            if ( $route[0] ) {\n                if ( ! preg_match($route[1], $path , $regs ) ) {\n                    continue;\n                }\n                $route[3]['vars'] = $regs;\n\n                \/\/ validate request method\n                if ( isset($route[3]['method']) && $route[3]['method'] != $requestMethod )\n                    continue;\n                if ( isset($route[3]['domain']) && $route[3]['domain'] != $_SERVER[\"HTTP_HOST\"] )\n                    continue;\n                if ( isset($route[3]['secure']) && $route[3]['secure'] && $_SERVER[\"HTTPS\"] )\n                    continue;\n                return $route;\n            } else {\n                \/\/ prefix match is used when expanding is not enabled.\n                if ( ( is_int($route[2]) && strncmp($route[1], $path, strlen($route[1]) ) === 0 ) || $route[1] == $path ) {\n                    \/\/ validate request method\n                    if ( isset($route[3]['method']) && $route[3]['method'] != $requestMethod )\n                        continue;\n                    if ( isset($route[3]['domain']) && $route[3]['domain'] != $_SERVER[\"HTTP_HOST\"] )\n                        continue;\n                    if ( isset($route[3]['secure']) && $route[3]['secure'] && $_SERVER[\"HTTPS\"] )\n                        continue;\n                    return $route;\n                } else {\n                    continue;\n                }\n            }\n        }\n    }\n\n    public function dispatch($path)\n    {\n        if ($route = $this->match($path) ) {\n            if (is_int($route[2])) {\n                $submux = $this->submux[ $route[2] ];\n\n                \/\/ sub-path and call submux to dispatch\n                \/\/ for pcre pattern?\n                if ($route[0]) { \n                    $matchedString = $route[3]['vars'][0];\n                    return $submux->dispatch( substr($path, strlen($matchedString)) );\n                } else {\n                    $s = substr($path, strlen($route[1]));\n                    return $submux->dispatch(\n                        substr($path, strlen($route[1])) ?: ''\n                    );\n                }\n            }\n            return $route;\n        }\n    }\n\n    public function length()\n    {\n        return count($this->routes);\n    }\n\n    public function getRoutes()\n    {\n        return $this->routes;\n    }\n\n    public function setRoutes($routes)\n    {\n        $this->routes = $routes;\n    }\n\n    public function export() {\n        return var_export($this, true);\n    }\n\n    public static function __set_state($array)\n    {\n        $mux = new self;\n        $mux->routes = $array['routes'];\n        $mux->submux = $array['submux'];\n        $mux->expand = $array['expand'];\n        if ( isset($array['routesById']) ) {\n            $mux->routesById = $array['routesById'];\n        }\n        $mux->id = $array['id'];\n        return $mux;\n    }\n\n}","coverage":[null,null,null,null,null,null,null,1,1,1,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,0,null,0,null,null,null,null,0,0,null,null,null,0,0,0,0,0,null,0,null,null,null,0,0,0,0,0,null,0,0,null,null,0,null,0,0,0,0,0,0,0,0,0,0,0,null,null,0,0,0,0,0,null,0,null,null,null,0,0,0,null,null,null,0,0,0,null,null,null,3,3,3,null,null,null,0,0,0,null,null,null,0,0,0,null,null,null,null,0,0,0,null,null,null,null,0,0,0,null,null,null,0,0,null,null,null,3,0,0,null,null,3,3,0,null,null,null,0,0,0,0,0,0,0,0,0,null,null,3,3,3,3,3,3,0,0,null,3,null,null,null,null,0,0,null,null,0,null,null,null,0,0,null,null,null,0,0,0,0,0,0,null,0,0,0,0,null,0,null,null,null,null,null,null,null,0,0,0,null,0,0,null,null,null,null,0,0,null,0,null,null,null,3,3,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,null,null,null,null,3,null,3,0,3,3,3,null,3,3,0,0,null,0,null,null,0,0,0,0,0,0,0,null,null,3,null,2,2,1,1,1,1,1,null,1,null,null,2,2,null,null,null,3,1,0,null,null,null,0,0,0,null,0,0,0,0,null,null,1,null,2,null,null,null,0,null,null,null,null,0,null,null,null,null,0,0,null,null,0,null,null,null,null,0,0,0,0,0,0,0,0,0,null,null,null]},{"name":"vendor\/zendframework\/zend-http\/src\/AbstractMessage.php","source":"<?php\n\/**\n * Zend Framework (http:\/\/framework.zend.com\/)\n *\n * @link      http:\/\/github.com\/zendframework\/zf2 for the canonical source repository\n * @copyright Copyright (c) 2005-2015 Zend Technologies USA Inc. (http:\/\/www.zend.com)\n * @license   http:\/\/framework.zend.com\/license\/new-bsd New BSD License\n *\/\n\nnamespace Zend\\Http;\n\nuse Zend\\Stdlib\\Message;\n\n\/**\n * HTTP standard message (Request\/Response)\n *\n * @link      http:\/\/www.w3.org\/Protocols\/rfc2616\/rfc2616-sec4.html#sec4\n *\/\nabstract class AbstractMessage extends Message\n{\n    \/**#@+\n     * @const string Version constant numbers\n     *\/\n    const VERSION_10 = '1.0';\n    const VERSION_11 = '1.1';\n    \/**#@-*\/\n\n    \/**\n     * @var string\n     *\/\n    protected $version = self::VERSION_11;\n\n    \/**\n     * @var Headers|null\n     *\/\n    protected $headers = null;\n\n    \/**\n     * Set the HTTP version for this object, one of 1.0 or 1.1\n     * (AbstractMessage::VERSION_10, AbstractMessage::VERSION_11)\n     *\n     * @param  string $version (Must be 1.0 or 1.1)\n     * @return AbstractMessage\n     * @throws Exception\\InvalidArgumentException\n     *\/\n    public function setVersion($version)\n    {\n        if ($version != self::VERSION_10 && $version != self::VERSION_11) {\n            throw new Exception\\InvalidArgumentException(\n                'Not valid or not supported HTTP version: ' . $version\n            );\n        }\n        $this->version = $version;\n        return $this;\n    }\n\n    \/**\n     * Return the HTTP version for this request\n     *\n     * @return string\n     *\/\n    public function getVersion()\n    {\n        return $this->version;\n    }\n\n    \/**\n     * Provide an alternate Parameter Container implementation for headers in this object,\n     * (this is NOT the primary API for value setting, for that see getHeaders())\n     *\n     * @see    getHeaders()\n     * @param  Headers $headers\n     * @return AbstractMessage\n     *\/\n    public function setHeaders(Headers $headers)\n    {\n        $this->headers = $headers;\n        return $this;\n    }\n\n    \/**\n     * Return the header container responsible for headers\n     *\n     * @return Headers\n     *\/\n    public function getHeaders()\n    {\n        if ($this->headers === null || is_string($this->headers)) {\n            \/\/ this is only here for fromString lazy loading\n            $this->headers = (is_string($this->headers)) ? Headers::fromString($this->headers) : new Headers();\n        }\n\n        return $this->headers;\n    }\n\n    \/**\n     * Allow PHP casting of this object\n     *\n     * @return string\n     *\/\n    public function __toString()\n    {\n        return $this->toString();\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,0,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,null,0,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null]},{"name":"vendor\/zendframework\/zend-http\/src\/Headers.php","source":"<?php\n\/**\n * Zend Framework (http:\/\/framework.zend.com\/)\n *\n * @link      http:\/\/github.com\/zendframework\/zf2 for the canonical source repository\n * @copyright Copyright (c) 2005-2015 Zend Technologies USA Inc. (http:\/\/www.zend.com)\n * @license   http:\/\/framework.zend.com\/license\/new-bsd New BSD License\n *\/\n\nnamespace Zend\\Http;\n\nuse ArrayIterator;\nuse Countable;\nuse Iterator;\nuse Traversable;\nuse Zend\\Loader\\PluginClassLocator;\n\n\/**\n * Basic HTTP headers collection functionality\n * Handles aggregation of headers\n *\n * @see        http:\/\/www.w3.org\/Protocols\/rfc2616\/rfc2616-sec4.html#sec4.2\n *\/\nclass Headers implements Countable, Iterator\n{\n    \/**\n     * @var PluginClassLocator\n     *\/\n    protected $pluginClassLoader = null;\n\n    \/**\n     * @var array key names for $headers array\n     *\/\n    protected $headersKeys = [];\n\n    \/**\n     * @var array Array of header array information or Header instances\n     *\/\n    protected $headers = [];\n\n    \/**\n     * Populates headers from string representation\n     *\n     * Parses a string for headers, and aggregates them, in order, in the\n     * current instance, primarily as strings until they are needed (they\n     * will be lazy loaded)\n     *\n     * @param  string $string\n     * @return Headers\n     * @throws Exception\\RuntimeException\n     *\/\n    public static function fromString($string)\n    {\n        $headers   = new static();\n        $current   = [];\n        $emptyLine = 0;\n\n        \/\/ iterate the header lines, some might be continuations\n        foreach (explode(\"\\r\\n\", $string) as $line) {\n            \/\/ CRLF*2 is end of headers; an empty line by itself or between header lines\n            \/\/ is an attempt at CRLF injection.\n            if (preg_match('\/^\\s*$\/', $line)) {\n                \/\/ empty line indicates end of headers\n                $emptyLine += 1;\n                if ($emptyLine > 2) {\n                    throw new Exception\\RuntimeException('Malformed header detected');\n                }\n                continue;\n            }\n\n            if ($emptyLine) {\n                throw new Exception\\RuntimeException('Malformed header detected');\n            }\n\n            \/\/ check if a header name is present\n            if (preg_match('\/^(?P<name>[^()><@,;:\\\"\\\\\/\\[\\]?={} \\t]+):.*$\/', $line, $matches)) {\n                if ($current) {\n                    \/\/ a header name was present, then store the current complete line\n                    $headers->headersKeys[] = static::createKey($current['name']);\n                    $headers->headers[]     = $current;\n                }\n                $current = [\n                    'name' => $matches['name'],\n                    'line' => trim($line)\n                ];\n\n                continue;\n            }\n\n            if (preg_match(\"\/^[ \\t][^\\r\\n]*$\/\", $line, $matches)) {\n                \/\/ continuation: append to current line\n                $current['line'] .= trim($line);\n                continue;\n            }\n\n            \/\/ Line does not match header format!\n            throw new Exception\\RuntimeException(sprintf(\n                'Line \"%s\" does not match header format!',\n                $line\n            ));\n        }\n        if ($current) {\n            $headers->headersKeys[] = static::createKey($current['name']);\n            $headers->headers[]     = $current;\n        }\n        return $headers;\n    }\n\n    \/**\n     * Set an alternate implementation for the PluginClassLoader\n     *\n     * @param \\Zend\\Loader\\PluginClassLocator $pluginClassLoader\n     * @return Headers\n     *\/\n    public function setPluginClassLoader(PluginClassLocator $pluginClassLoader)\n    {\n        $this->pluginClassLoader = $pluginClassLoader;\n        return $this;\n    }\n\n    \/**\n     * Return an instance of a PluginClassLocator, lazyload and inject map if necessary\n     *\n     * @return PluginClassLocator\n     *\/\n    public function getPluginClassLoader()\n    {\n        if ($this->pluginClassLoader === null) {\n            $this->pluginClassLoader = new HeaderLoader();\n        }\n        return $this->pluginClassLoader;\n    }\n\n    \/**\n     * Add many headers at once\n     *\n     * Expects an array (or Traversable object) of type\/value pairs.\n     *\n     * @param  array|Traversable $headers\n     * @return Headers\n     * @throws Exception\\InvalidArgumentException\n     *\/\n    public function addHeaders($headers)\n    {\n        if (!is_array($headers) && !$headers instanceof Traversable) {\n            throw new Exception\\InvalidArgumentException(sprintf(\n                'Expected array or Traversable; received \"%s\"',\n                (is_object($headers) ? get_class($headers) : gettype($headers))\n            ));\n        }\n\n        foreach ($headers as $name => $value) {\n            if (is_int($name)) {\n                if (is_string($value)) {\n                    $this->addHeaderLine($value);\n                } elseif (is_array($value) && count($value) == 1) {\n                    $this->addHeaderLine(key($value), current($value));\n                } elseif (is_array($value) && count($value) == 2) {\n                    $this->addHeaderLine($value[0], $value[1]);\n                } elseif ($value instanceof Header\\HeaderInterface) {\n                    $this->addHeader($value);\n                }\n            } elseif (is_string($name)) {\n                $this->addHeaderLine($name, $value);\n            }\n        }\n\n        return $this;\n    }\n\n    \/**\n     * Add a raw header line, either in name => value, or as a single string 'name: value'\n     *\n     * This method allows for lazy-loading in that the parsing and instantiation of Header object\n     * will be delayed until they are retrieved by either get() or current()\n     *\n     * @throws Exception\\InvalidArgumentException\n     * @param string $headerFieldNameOrLine\n     * @param string $fieldValue optional\n     * @return Headers\n     *\/\n    public function addHeaderLine($headerFieldNameOrLine, $fieldValue = null)\n    {\n        $matches = null;\n        if (preg_match('\/^(?P<name>[^()><@,;:\\\"\\\\\/\\[\\]?=}{ \\t]+):.*$\/', $headerFieldNameOrLine, $matches)\n            && $fieldValue === null) {\n            \/\/ is a header\n            $headerName = $matches['name'];\n            $headerKey  = static::createKey($matches['name']);\n            $line = $headerFieldNameOrLine;\n        } elseif ($fieldValue === null) {\n            throw new Exception\\InvalidArgumentException('A field name was provided without a field value');\n        } else {\n            $headerName = $headerFieldNameOrLine;\n            $headerKey  = static::createKey($headerFieldNameOrLine);\n            if (is_array($fieldValue)) {\n                $fieldValue = implode(', ', $fieldValue);\n            }\n            $line = $headerFieldNameOrLine . ': ' . $fieldValue;\n        }\n\n        $this->headersKeys[] = $headerKey;\n        $this->headers[]     = ['name' => $headerName, 'line' => $line];\n\n        return $this;\n    }\n\n    \/**\n     * Add a Header to this container, for raw values @see addHeaderLine() and addHeaders()\n     *\n     * @param  Header\\HeaderInterface $header\n     * @return Headers\n     *\/\n    public function addHeader(Header\\HeaderInterface $header)\n    {\n        $this->headersKeys[] = static::createKey($header->getFieldName());\n        $this->headers[]     = $header;\n\n        return $this;\n    }\n\n    \/**\n     * Remove a Header from the container\n     *\n     * @param Header\\HeaderInterface $header\n     * @return bool\n     *\/\n    public function removeHeader(Header\\HeaderInterface $header)\n    {\n        $index = array_search($header, $this->headers, true);\n        if ($index !== false) {\n            unset($this->headersKeys[$index]);\n            unset($this->headers[$index]);\n\n            return true;\n        }\n        return false;\n    }\n\n    \/**\n     * Clear all headers\n     *\n     * Removes all headers from queue\n     *\n     * @return Headers\n     *\/\n    public function clearHeaders()\n    {\n        $this->headers = $this->headersKeys = [];\n        return $this;\n    }\n\n    \/**\n     * Get all headers of a certain name\/type\n     *\n     * @param  string $name\n     * @return bool|Header\\HeaderInterface|ArrayIterator\n     *\/\n    public function get($name)\n    {\n        $key = static::createKey($name);\n        if (!in_array($key, $this->headersKeys)) {\n            return false;\n        }\n\n        $class = ($this->getPluginClassLoader()->load($key)) ?: 'Zend\\Http\\Header\\GenericHeader';\n\n        if (in_array('Zend\\Http\\Header\\MultipleHeaderInterface', class_implements($class, true))) {\n            $headers = [];\n            foreach (array_keys($this->headersKeys, $key) as $index) {\n                if (is_array($this->headers[$index])) {\n                    $this->lazyLoadHeader($index);\n                }\n            }\n            foreach (array_keys($this->headersKeys, $key) as $index) {\n                $headers[] = $this->headers[$index];\n            }\n            return new ArrayIterator($headers);\n        }\n\n        $index = array_search($key, $this->headersKeys);\n        if ($index === false) {\n            return false;\n        }\n\n        if (is_array($this->headers[$index])) {\n            return $this->lazyLoadHeader($index);\n        }\n        return $this->headers[$index];\n    }\n\n    \/**\n     * Test for existence of a type of header\n     *\n     * @param  string $name\n     * @return bool\n     *\/\n    public function has($name)\n    {\n        return (in_array(static::createKey($name), $this->headersKeys));\n    }\n\n    \/**\n     * Advance the pointer for this object as an iterator\n     *\n     * @return void\n     *\/\n    public function next()\n    {\n        next($this->headers);\n    }\n\n    \/**\n     * Return the current key for this object as an iterator\n     *\n     * @return mixed\n     *\/\n    public function key()\n    {\n        return (key($this->headers));\n    }\n\n    \/**\n     * Is this iterator still valid?\n     *\n     * @return bool\n     *\/\n    public function valid()\n    {\n        return (current($this->headers) !== false);\n    }\n\n    \/**\n     * Reset the internal pointer for this object as an iterator\n     *\n     * @return void\n     *\/\n    public function rewind()\n    {\n        reset($this->headers);\n    }\n\n    \/**\n     * Return the current value for this iterator, lazy loading it if need be\n     *\n     * @return array|Header\\HeaderInterface\n     *\/\n    public function current()\n    {\n        $current = current($this->headers);\n        if (is_array($current)) {\n            $current = $this->lazyLoadHeader(key($this->headers));\n        }\n        return $current;\n    }\n\n    \/**\n     * Return the number of headers in this contain, if all headers have not been parsed, actual count could\n     * increase if MultipleHeader objects exist in the Request\/Response.  If you need an exact count, iterate\n     *\n     * @return int count of currently known headers\n     *\/\n    public function count()\n    {\n        return count($this->headers);\n    }\n\n    \/**\n     * Render all headers at once\n     *\n     * This method handles the normal iteration of headers; it is up to the\n     * concrete classes to prepend with the appropriate status\/request line.\n     *\n     * @return string\n     *\/\n    public function toString()\n    {\n        $headers = '';\n        foreach ($this->toArray() as $fieldName => $fieldValue) {\n            if (is_array($fieldValue)) {\n                \/\/ Handle multi-value headers\n                foreach ($fieldValue as $value) {\n                    $headers .= $fieldName . ': ' . $value . \"\\r\\n\";\n                }\n                continue;\n            }\n            \/\/ Handle single-value headers\n            $headers .= $fieldName . ': ' . $fieldValue . \"\\r\\n\";\n        }\n        return $headers;\n    }\n\n    \/**\n     * Return the headers container as an array\n     *\n     * @todo determine how to produce single line headers, if they are supported\n     * @return array\n     *\/\n    public function toArray()\n    {\n        $headers = [];\n        \/* @var $header Header\\HeaderInterface *\/\n        foreach ($this->headers as $header) {\n            if ($header instanceof Header\\MultipleHeaderInterface) {\n                $name = $header->getFieldName();\n                if (!isset($headers[$name])) {\n                    $headers[$name] = [];\n                }\n                $headers[$name][] = $header->getFieldValue();\n            } elseif ($header instanceof Header\\HeaderInterface) {\n                $headers[$header->getFieldName()] = $header->getFieldValue();\n            } else {\n                $matches = null;\n                preg_match('\/^(?P<name>[^()><@,;:\\\"\\\\\/\\[\\]?=}{ \\t]+):\\s*(?P<value>.*)$\/', $header['line'], $matches);\n                if ($matches) {\n                    $headers[$matches['name']] = $matches['value'];\n                }\n            }\n        }\n        return $headers;\n    }\n\n    \/**\n     * By calling this, it will force parsing and loading of all headers, after this count() will be accurate\n     *\n     * @return bool\n     *\/\n    public function forceLoading()\n    {\n        foreach ($this as $item) {\n            \/\/ $item should now be loaded\n        }\n        return true;\n    }\n\n    \/**\n     * @param $index\n     * @return mixed|void\n     *\/\n    protected function lazyLoadHeader($index)\n    {\n        $current = $this->headers[$index];\n\n        $key = $this->headersKeys[$index];\n        \/* @var $class Header\\HeaderInterface *\/\n        $class = ($this->getPluginClassLoader()->load($key)) ?: 'Zend\\Http\\Header\\GenericHeader';\n\n        $headers = $class::fromString($current['line']);\n        if (is_array($headers)) {\n            $this->headers[$index] = $current = array_shift($headers);\n            foreach ($headers as $header) {\n                $this->headersKeys[] = $key;\n                $this->headers[]     = $header;\n            }\n            return $current;\n        }\n\n        $this->headers[$index] = $current = $headers;\n        return $current;\n    }\n\n    \/**\n     * Create array key from header name\n     *\n     * @param string $name\n     * @return string\n     *\/\n    protected static function createKey($name)\n    {\n        return str_replace(['-', '_', ' ', '.'], '', strtolower($name));\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,null,0,null,null,0,null,0,0,0,null,0,null,null,0,0,null,null,null,0,0,null,0,0,0,null,0,0,0,null,0,null,null,0,null,0,0,null,null,null,0,0,null,0,0,0,0,0,0,0,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,4,0,0,0,0,null,null,4,0,0,0,0,0,0,0,0,0,0,0,0,0,4,null,4,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,0,0,0,0,null,0,0,0,0,0,0,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,4,4,4,null,null,0,null,0,0,0,0,0,0,0,0,0,0,0,null,null,0,0,0,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,0,0,0,0,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,0,0,0,null,null,0,0,0,null,null,null,null,null,null,null,null,null,null,0,null,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,null,0,0,null,null,null,null,null,null,null,null,null,0,null,0,0,null,null,null,null,null,null,null,null,0,null,0,null,0,null,0,0,0,0,0,0,0,0,null,null,0,0,null,null,null,null,null,null,null,null,null,null,4,null,null]},{"name":"vendor\/zendframework\/zend-http\/src\/PhpEnvironment\/Request.php","source":"<?php\n\/**\n * Zend Framework (http:\/\/framework.zend.com\/)\n *\n * @link      http:\/\/github.com\/zendframework\/zf2 for the canonical source repository\n * @copyright Copyright (c) 2005-2015 Zend Technologies USA Inc. (http:\/\/www.zend.com)\n * @license   http:\/\/framework.zend.com\/license\/new-bsd New BSD License\n *\/\n\nnamespace Zend\\Http\\PhpEnvironment;\n\nuse Zend\\Http\\Header\\Cookie;\nuse Zend\\Http\\Request as HttpRequest;\nuse Zend\\Stdlib\\Parameters;\nuse Zend\\Stdlib\\ParametersInterface;\nuse Zend\\Uri\\Http as HttpUri;\nuse Zend\\Validator\\Hostname as HostnameValidator;\n\n\/**\n * HTTP Request for current PHP environment\n *\/\nclass Request extends HttpRequest\n{\n    \/**\n     * Base URL of the application.\n     *\n     * @var string\n     *\/\n    protected $baseUrl;\n\n    \/**\n     * Base Path of the application.\n     *\n     * @var string\n     *\/\n    protected $basePath;\n\n    \/**\n     * Actual request URI, independent of the platform.\n     *\n     * @var string\n     *\/\n    protected $requestUri;\n\n    \/**\n     * PHP server params ($_SERVER)\n     *\n     * @var ParametersInterface\n     *\/\n    protected $serverParams = null;\n\n    \/**\n     * PHP environment params ($_ENV)\n     *\n     * @var ParametersInterface\n     *\/\n    protected $envParams = null;\n\n    \/**\n     * Construct\n     * Instantiates request.\n     *\n     * @param bool $allowCustomMethods\n     *\/\n    public function __construct($allowCustomMethods = true)\n    {\n        $this->setAllowCustomMethods($allowCustomMethods);\n\n        $this->setEnv(new Parameters($_ENV));\n\n        if ($_GET) {\n            $this->setQuery(new Parameters($_GET));\n        }\n        if ($_POST) {\n            $this->setPost(new Parameters($_POST));\n        }\n        if ($_COOKIE) {\n            $this->setCookies(new Parameters($_COOKIE));\n        }\n        if ($_FILES) {\n            \/\/ convert PHP $_FILES superglobal\n            $files = $this->mapPhpFiles();\n            $this->setFiles(new Parameters($files));\n        }\n\n        $this->setServer(new Parameters($_SERVER));\n    }\n\n    \/**\n     * Get raw request body\n     *\n     * @return string\n     *\/\n    public function getContent()\n    {\n        if (empty($this->content)) {\n            $requestBody = file_get_contents('php:\/\/input');\n            if (strlen($requestBody) > 0) {\n                $this->content = $requestBody;\n            }\n        }\n\n        return $this->content;\n    }\n\n    \/**\n     * Set cookies\n     *\n     * Instantiate and set cookies.\n     *\n     * @param $cookie\n     * @return Request\n     *\/\n    public function setCookies($cookie)\n    {\n        $this->getHeaders()->addHeader(new Cookie((array) $cookie));\n        return $this;\n    }\n\n    \/**\n     * Set the request URI.\n     *\n     * @param  string $requestUri\n     * @return self\n     *\/\n    public function setRequestUri($requestUri)\n    {\n        $this->requestUri = $requestUri;\n        return $this;\n    }\n\n    \/**\n     * Get the request URI.\n     *\n     * @return string\n     *\/\n    public function getRequestUri()\n    {\n        if ($this->requestUri === null) {\n            $this->requestUri = $this->detectRequestUri();\n        }\n        return $this->requestUri;\n    }\n\n    \/**\n     * Set the base URL.\n     *\n     * @param  string $baseUrl\n     * @return self\n     *\/\n    public function setBaseUrl($baseUrl)\n    {\n        $this->baseUrl = rtrim($baseUrl, '\/');\n        return $this;\n    }\n\n    \/**\n     * Get the base URL.\n     *\n     * @return string\n     *\/\n    public function getBaseUrl()\n    {\n        if ($this->baseUrl === null) {\n            $this->setBaseUrl($this->detectBaseUrl());\n        }\n        return $this->baseUrl;\n    }\n\n    \/**\n     * Set the base path.\n     *\n     * @param  string $basePath\n     * @return self\n     *\/\n    public function setBasePath($basePath)\n    {\n        $this->basePath = rtrim($basePath, '\/');\n        return $this;\n    }\n\n    \/**\n     * Get the base path.\n     *\n     * @return string\n     *\/\n    public function getBasePath()\n    {\n        if ($this->basePath === null) {\n            $this->setBasePath($this->detectBasePath());\n        }\n\n        return $this->basePath;\n    }\n\n    \/**\n     * Provide an alternate Parameter Container implementation for server parameters in this object,\n     * (this is NOT the primary API for value setting, for that see getServer())\n     *\n     * @param  ParametersInterface $server\n     * @return Request\n     *\/\n    public function setServer(ParametersInterface $server)\n    {\n        $this->serverParams = $server;\n\n        \/\/ This seems to be the only way to get the Authorization header on Apache\n        if (function_exists('apache_request_headers')) {\n            $apacheRequestHeaders = apache_request_headers();\n            if (!isset($this->serverParams['HTTP_AUTHORIZATION'])) {\n                if (isset($apacheRequestHeaders['Authorization'])) {\n                    $this->serverParams->set('HTTP_AUTHORIZATION', $apacheRequestHeaders['Authorization']);\n                } elseif (isset($apacheRequestHeaders['authorization'])) {\n                    $this->serverParams->set('HTTP_AUTHORIZATION', $apacheRequestHeaders['authorization']);\n                }\n            }\n        }\n\n        \/\/ set headers\n        $headers = [];\n\n        foreach ($server as $key => $value) {\n            if ($value || (!is_array($value) && strlen($value))) {\n                if (strpos($key, 'HTTP_') === 0) {\n                    if (strpos($key, 'HTTP_COOKIE') === 0) {\n                        \/\/ Cookies are handled using the $_COOKIE superglobal\n                        continue;\n                    }\n\n                    $headers[strtr(ucwords(strtolower(strtr(substr($key, 5), '_', ' '))), ' ', '-')] = $value;\n                } elseif (strpos($key, 'CONTENT_') === 0) {\n                    $name = substr($key, 8); \/\/ Remove \"Content-\"\n                    $headers['Content-' . (($name == 'MD5') ? $name : ucfirst(strtolower($name)))] = $value;\n                }\n            }\n        }\n\n        $this->getHeaders()->addHeaders($headers);\n\n        \/\/ set method\n        if (isset($this->serverParams['REQUEST_METHOD'])) {\n            $this->setMethod($this->serverParams['REQUEST_METHOD']);\n        }\n\n        \/\/ set HTTP version\n        if (isset($this->serverParams['SERVER_PROTOCOL'])\n            && strpos($this->serverParams['SERVER_PROTOCOL'], self::VERSION_10) !== false\n        ) {\n            $this->setVersion(self::VERSION_10);\n        }\n\n        \/\/ set URI\n        $uri = new HttpUri();\n\n        \/\/ URI scheme\n        if ((!empty($this->serverParams['HTTPS']) && strtolower($this->serverParams['HTTPS']) !== 'off')\n            || (!empty($this->serverParams['HTTP_X_FORWARDED_PROTO'])\n                 && $this->serverParams['HTTP_X_FORWARDED_PROTO'] == 'https')\n        ) {\n            $scheme = 'https';\n        } else {\n            $scheme = 'http';\n        }\n        $uri->setScheme($scheme);\n\n        \/\/ URI host & port\n        $host = null;\n        $port = null;\n\n        \/\/ Set the host\n        if ($this->getHeaders()->get('host')) {\n            $host = $this->getHeaders()->get('host')->getFieldValue();\n\n            \/\/ works for regname, IPv4 & IPv6\n            if (preg_match('|\\:(\\d+)$|', $host, $matches)) {\n                $host = substr($host, 0, -1 * (strlen($matches[1]) + 1));\n                $port = (int) $matches[1];\n            }\n\n            \/\/ set up a validator that check if the hostname is legal (not spoofed)\n            $hostnameValidator = new HostnameValidator([\n                'allow'       => HostnameValidator::ALLOW_ALL,\n                'useIdnCheck' => false,\n                'useTldCheck' => false,\n            ]);\n            \/\/ If invalid. Reset the host & port\n            if (!$hostnameValidator->isValid($host)) {\n                $host = null;\n                $port = null;\n            }\n        }\n\n        if (!$host && isset($this->serverParams['SERVER_NAME'])) {\n            $host = $this->serverParams['SERVER_NAME'];\n            if (isset($this->serverParams['SERVER_PORT'])) {\n                $port = (int) $this->serverParams['SERVER_PORT'];\n            }\n            \/\/ Check for missinterpreted IPv6-Address\n            \/\/ Reported at least for Safari on Windows\n            if (isset($this->serverParams['SERVER_ADDR']) && preg_match('\/^\\[[0-9a-fA-F\\:]+\\]$\/', $host)) {\n                $host = '[' . $this->serverParams['SERVER_ADDR'] . ']';\n                if ($port . ']' == substr($host, strrpos($host, ':')+1)) {\n                    \/\/ The last digit of the IPv6-Address has been taken as port\n                    \/\/ Unset the port so the default port can be used\n                    $port = null;\n                }\n            }\n        }\n        $uri->setHost($host);\n        $uri->setPort($port);\n\n        \/\/ URI path\n        $requestUri = $this->getRequestUri();\n        if (($qpos = strpos($requestUri, '?')) !== false) {\n            $requestUri = substr($requestUri, 0, $qpos);\n        }\n\n        $uri->setPath($requestUri);\n\n        \/\/ URI query\n        if (isset($this->serverParams['QUERY_STRING'])) {\n            $uri->setQuery($this->serverParams['QUERY_STRING']);\n        }\n\n        $this->setUri($uri);\n\n        return $this;\n    }\n\n    \/**\n     * Return the parameter container responsible for server parameters or a single parameter value.\n     *\n     * @param string|null           $name            Parameter name to retrieve, or null to get the whole container.\n     * @param mixed|null            $default         Default value to use when the parameter is missing.\n     * @see http:\/\/www.faqs.org\/rfcs\/rfc3875.html\n     * @return \\Zend\\Stdlib\\ParametersInterface|mixed\n     *\/\n    public function getServer($name = null, $default = null)\n    {\n        if ($this->serverParams === null) {\n            $this->serverParams = new Parameters();\n        }\n\n        if ($name === null) {\n            return $this->serverParams;\n        }\n\n        return $this->serverParams->get($name, $default);\n    }\n\n    \/**\n     * Provide an alternate Parameter Container implementation for env parameters in this object,\n     * (this is NOT the primary API for value setting, for that see env())\n     *\n     * @param  ParametersInterface $env\n     * @return Request\n     *\/\n    public function setEnv(ParametersInterface $env)\n    {\n        $this->envParams = $env;\n        return $this;\n    }\n\n    \/**\n     * Return the parameter container responsible for env parameters or a single parameter value.\n     *\n     * @param string|null           $name            Parameter name to retrieve, or null to get the whole container.\n     * @param mixed|null            $default         Default value to use when the parameter is missing.\n     * @return \\Zend\\Stdlib\\ParametersInterface|mixed\n     *\/\n    public function getEnv($name = null, $default = null)\n    {\n        if ($this->envParams === null) {\n            $this->envParams = new Parameters();\n        }\n\n        if ($name === null) {\n            return $this->envParams;\n        }\n\n        return $this->envParams->get($name, $default);\n    }\n\n    \/**\n     * Convert PHP superglobal $_FILES into more sane parameter=value structure\n     * This handles form file input with brackets (name=files[])\n     *\n     * @return array\n     *\/\n    protected function mapPhpFiles()\n    {\n        $files = [];\n        foreach ($_FILES as $fileName => $fileParams) {\n            $files[$fileName] = [];\n            foreach ($fileParams as $param => $data) {\n                if (!is_array($data)) {\n                    $files[$fileName][$param] = $data;\n                } else {\n                    foreach ($data as $i => $v) {\n                        $this->mapPhpFileParam($files[$fileName], $param, $i, $v);\n                    }\n                }\n            }\n        }\n\n        return $files;\n    }\n\n    \/**\n     * @param array        $array\n     * @param string       $paramName\n     * @param int|string   $index\n     * @param string|array $value\n     *\/\n    protected function mapPhpFileParam(&$array, $paramName, $index, $value)\n    {\n        if (!is_array($value)) {\n            $array[$index][$paramName] = $value;\n        } else {\n            foreach ($value as $i => $v) {\n                $this->mapPhpFileParam($array[$index], $paramName, $i, $v);\n            }\n        }\n    }\n\n    \/**\n     * Detect the base URI for the request\n     *\n     * Looks at a variety of criteria in order to attempt to autodetect a base\n     * URI, including rewrite URIs, proxy URIs, etc.\n     *\n     * @return string\n     *\/\n    protected function detectRequestUri()\n    {\n        $requestUri = null;\n        $server     = $this->getServer();\n\n        \/\/ Check this first so IIS will catch.\n        $httpXRewriteUrl = $server->get('HTTP_X_REWRITE_URL');\n        if ($httpXRewriteUrl !== null) {\n            $requestUri = $httpXRewriteUrl;\n        }\n\n        \/\/ Check for IIS 7.0 or later with ISAPI_Rewrite\n        $httpXOriginalUrl = $server->get('HTTP_X_ORIGINAL_URL');\n        if ($httpXOriginalUrl !== null) {\n            $requestUri = $httpXOriginalUrl;\n        }\n\n        \/\/ IIS7 with URL Rewrite: make sure we get the unencoded url\n        \/\/ (double slash problem).\n        $iisUrlRewritten = $server->get('IIS_WasUrlRewritten');\n        $unencodedUrl    = $server->get('UNENCODED_URL', '');\n        if ('1' == $iisUrlRewritten && '' !== $unencodedUrl) {\n            return $unencodedUrl;\n        }\n\n        \/\/ HTTP proxy requests setup request URI with scheme and host [and port]\n        \/\/ + the URL path, only use URL path.\n        if (!$httpXRewriteUrl) {\n            $requestUri = $server->get('REQUEST_URI');\n        }\n\n        if ($requestUri !== null) {\n            return preg_replace('#^[^\/:]+:\/\/[^\/]+#', '', $requestUri);\n        }\n\n        \/\/ IIS 5.0, PHP as CGI.\n        $origPathInfo = $server->get('ORIG_PATH_INFO');\n        if ($origPathInfo !== null) {\n            $queryString = $server->get('QUERY_STRING', '');\n            if ($queryString !== '') {\n                $origPathInfo .= '?' . $queryString;\n            }\n            return $origPathInfo;\n        }\n\n        return '\/';\n    }\n\n    \/**\n     * Auto-detect the base path from the request environment\n     *\n     * Uses a variety of criteria in order to detect the base URL of the request\n     * (i.e., anything additional to the document root).\n     *\n     *\n     * @return string\n     *\/\n    protected function detectBaseUrl()\n    {\n        $filename       = $this->getServer()->get('SCRIPT_FILENAME', '');\n        $scriptName     = $this->getServer()->get('SCRIPT_NAME');\n        $phpSelf        = $this->getServer()->get('PHP_SELF');\n        $origScriptName = $this->getServer()->get('ORIG_SCRIPT_NAME');\n\n        if ($scriptName !== null && basename($scriptName) === $filename) {\n            $baseUrl = $scriptName;\n        } elseif ($phpSelf !== null && basename($phpSelf) === $filename) {\n            $baseUrl = $phpSelf;\n        } elseif ($origScriptName !== null && basename($origScriptName) === $filename) {\n            \/\/ 1and1 shared hosting compatibility.\n            $baseUrl = $origScriptName;\n        } else {\n            \/\/ Backtrack up the SCRIPT_FILENAME to find the portion\n            \/\/ matching PHP_SELF.\n\n            $baseUrl  = '\/';\n            $basename = basename($filename);\n            if ($basename) {\n                $path     = ($phpSelf ? trim($phpSelf, '\/') : '');\n                $basePos  = strpos($path, $basename) ?: 0;\n                $baseUrl .= substr($path, 0, $basePos) . $basename;\n            }\n        }\n\n        \/\/ If the baseUrl is empty, then simply return it.\n        if (empty($baseUrl)) {\n            return '';\n        }\n\n        \/\/ Does the base URL have anything in common with the request URI?\n        $requestUri = $this->getRequestUri();\n\n        \/\/ Full base URL matches.\n        if (0 === strpos($requestUri, $baseUrl)) {\n            return $baseUrl;\n        }\n\n        \/\/ Directory portion of base path matches.\n        $baseDir = str_replace('\\\\', '\/', dirname($baseUrl));\n        if (0 === strpos($requestUri, $baseDir)) {\n            return $baseDir;\n        }\n\n        $truncatedRequestUri = $requestUri;\n\n        if (false !== ($pos = strpos($requestUri, '?'))) {\n            $truncatedRequestUri = substr($requestUri, 0, $pos);\n        }\n\n        $basename = basename($baseUrl);\n\n        \/\/ No match whatsoever\n        if (empty($basename) || false === strpos($truncatedRequestUri, $basename)) {\n            return '';\n        }\n\n        \/\/ If using mod_rewrite or ISAPI_Rewrite strip the script filename\n        \/\/ out of the base path. $pos !== 0 makes sure it is not matching a\n        \/\/ value from PATH_INFO or QUERY_STRING.\n        if (strlen($requestUri) >= strlen($baseUrl)\n            && (false !== ($pos = strpos($requestUri, $baseUrl)) && $pos !== 0)\n        ) {\n            $baseUrl = substr($requestUri, 0, $pos + strlen($baseUrl));\n        }\n\n        return $baseUrl;\n    }\n\n    \/**\n     * Autodetect the base path of the request\n     *\n     * Uses several criteria to determine the base path of the request.\n     *\n     * @return string\n     *\/\n    protected function detectBasePath()\n    {\n        $filename = basename($this->getServer()->get('SCRIPT_FILENAME', ''));\n        $baseUrl  = $this->getBaseUrl();\n\n        \/\/ Empty base url detected\n        if ($baseUrl === '') {\n            return '';\n        }\n\n        \/\/ basename() matches the script filename; return the directory\n        if (basename($baseUrl) === $filename) {\n            return str_replace('\\\\', '\/', dirname($baseUrl));\n        }\n\n        \/\/ Base path is identical to base URL\n        return $baseUrl;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,null,4,null,4,0,0,4,0,0,4,0,0,4,null,0,0,0,null,4,4,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,3,3,null,null,null,null,null,null,null,null,null,4,4,4,4,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,4,null,null,4,0,0,0,0,0,0,0,0,0,null,null,4,null,4,4,4,0,null,0,null,null,0,4,0,0,0,4,4,null,4,null,null,4,0,0,null,null,4,4,4,0,0,null,null,4,null,null,4,4,4,4,0,0,4,null,4,null,null,4,4,null,null,4,0,null,null,0,0,0,0,null,null,0,0,0,0,0,null,0,0,0,0,0,null,4,0,0,0,0,null,null,0,0,0,null,null,0,0,0,0,4,4,null,null,4,4,0,0,null,4,null,null,4,0,0,null,4,null,4,null,null,null,null,null,null,null,null,null,null,null,null,4,0,0,null,4,4,null,null,0,null,null,null,null,null,null,null,null,null,null,null,4,4,null,null,null,null,null,null,null,null,null,null,1,0,0,0,null,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,0,0,0,0,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,4,4,null,null,4,4,0,0,null,null,4,4,0,0,null,null,null,4,4,4,0,null,null,null,null,4,4,4,null,4,0,null,null,null,4,4,0,0,0,0,0,null,null,4,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,0,0,0,0,0,null,0,0,null,null,null,0,0,0,0,0,0,0,null,null,null,0,0,null,null,null,0,null,null,0,0,null,null,null,0,0,0,null,null,0,null,0,0,0,null,0,null,null,0,0,null,null,null,null,null,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,0,null,null,null,0,0,null,null,null,0,null,null]},{"name":"vendor\/zendframework\/zend-http\/src\/PhpEnvironment\/Response.php","source":"<?php\n\/**\n * Zend Framework (http:\/\/framework.zend.com\/)\n *\n * @link      http:\/\/github.com\/zendframework\/zf2 for the canonical source repository\n * @copyright Copyright (c) 2005-2015 Zend Technologies USA Inc. (http:\/\/www.zend.com)\n * @license   http:\/\/framework.zend.com\/license\/new-bsd New BSD License\n *\/\n\nnamespace Zend\\Http\\PhpEnvironment;\n\nuse Zend\\Http\\Header\\MultipleHeaderInterface;\nuse Zend\\Http\\Response as HttpResponse;\n\n\/**\n * HTTP Response for current PHP environment\n *\/\nclass Response extends HttpResponse\n{\n    \/**\n     * The current used version\n     * (The value will be detected on getVersion)\n     *\n     * @var null|string\n     *\/\n    protected $version;\n\n    \/**\n     * @var bool\n     *\/\n    protected $contentSent = false;\n\n    \/**\n     * Return the HTTP version for this response\n     *\n     * @return string\n     * @see \\Zend\\Http\\AbstractMessage::getVersion()\n     *\/\n    public function getVersion()\n    {\n        if (!$this->version) {\n            $this->version = $this->detectVersion();\n        }\n        return $this->version;\n    }\n\n    \/**\n     * Detect the current used protocol version.\n     * If detection failed it falls back to version 1.0.\n     *\n     * @return string\n     *\/\n    protected function detectVersion()\n    {\n        if (isset($_SERVER['SERVER_PROTOCOL']) && $_SERVER['SERVER_PROTOCOL'] == 'HTTP\/1.1') {\n            return self::VERSION_11;\n        }\n\n        return self::VERSION_10;\n    }\n\n    \/**\n     * @return bool\n     *\/\n    public function headersSent()\n    {\n        return headers_sent();\n    }\n\n    \/**\n     * @return bool\n     *\/\n    public function contentSent()\n    {\n        return $this->contentSent;\n    }\n\n    \/**\n     * Send HTTP headers\n     *\n     * @return Response\n     *\/\n    public function sendHeaders()\n    {\n        if ($this->headersSent()) {\n            return $this;\n        }\n\n        $status  = $this->renderStatusLine();\n        header($status);\n\n        \/** @var \\Zend\\Http\\Header\\HeaderInterface $header *\/\n        foreach ($this->getHeaders() as $header) {\n            if ($header instanceof MultipleHeaderInterface) {\n                header($header->toString(), false);\n                continue;\n            }\n            header($header->toString());\n        }\n\n        $this->headersSent = true;\n        return $this;\n    }\n\n    \/**\n     * Send content\n     *\n     * @return Response\n     *\/\n    public function sendContent()\n    {\n        if ($this->contentSent()) {\n            return $this;\n        }\n\n        echo $this->getContent();\n        $this->contentSent = true;\n        return $this;\n    }\n\n    \/**\n     * Send HTTP response\n     *\n     * @return Response\n     *\/\n    public function send()\n    {\n        $this->sendHeaders()\n             ->sendContent();\n        return $this;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,null,0,0,null,null,0,0,0,0,null,0,0,null,0,0,null,null,null,null,null,null,null,null,null,0,0,null,null,0,0,0,null,null,null,null,null,null,null,null,null,0,0,0,null,null]},{"name":"vendor\/zendframework\/zend-http\/src\/Request.php","source":"<?php\n\/**\n * Zend Framework (http:\/\/framework.zend.com\/)\n *\n * @link      http:\/\/github.com\/zendframework\/zf2 for the canonical source repository\n * @copyright Copyright (c) 2005-2015 Zend Technologies USA Inc. (http:\/\/www.zend.com)\n * @license   http:\/\/framework.zend.com\/license\/new-bsd New BSD License\n *\/\n\nnamespace Zend\\Http;\n\nuse Zend\\Stdlib\\Parameters;\nuse Zend\\Stdlib\\ParametersInterface;\nuse Zend\\Stdlib\\RequestInterface;\nuse Zend\\Uri\\Exception as UriException;\nuse Zend\\Uri\\Http as HttpUri;\n\n\/**\n * HTTP Request\n *\n * @link      http:\/\/www.w3.org\/Protocols\/rfc2616\/rfc2616-sec5.html#sec5\n *\/\nclass Request extends AbstractMessage implements RequestInterface\n{\n    \/**#@+\n     * @const string METHOD constant names\n     *\/\n    const METHOD_OPTIONS  = 'OPTIONS';\n    const METHOD_GET      = 'GET';\n    const METHOD_HEAD     = 'HEAD';\n    const METHOD_POST     = 'POST';\n    const METHOD_PUT      = 'PUT';\n    const METHOD_DELETE   = 'DELETE';\n    const METHOD_TRACE    = 'TRACE';\n    const METHOD_CONNECT  = 'CONNECT';\n    const METHOD_PATCH    = 'PATCH';\n    const METHOD_PROPFIND = 'PROPFIND';\n    \/**#@-*\/\n\n    \/**\n     * @var string\n     *\/\n    protected $method = self::METHOD_GET;\n\n    \/**\n     * @var bool\n     *\/\n    protected $allowCustomMethods = true;\n\n    \/**\n     * @var string|HttpUri\n     *\/\n    protected $uri = null;\n\n    \/**\n     * @var ParametersInterface\n     *\/\n    protected $queryParams = null;\n\n    \/**\n     * @var ParametersInterface\n     *\/\n    protected $postParams = null;\n\n    \/**\n     * @var ParametersInterface\n     *\/\n    protected $fileParams = null;\n\n    \/**\n     * A factory that produces a Request object from a well-formed Http Request string\n     *\n     * @param  string $string\n     * @param  bool $allowCustomMethods\n     * @throws Exception\\InvalidArgumentException\n     * @return Request\n     *\/\n    public static function fromString($string, $allowCustomMethods = true)\n    {\n        $request = new static();\n        $request->setAllowCustomMethods($allowCustomMethods);\n\n        $lines = explode(\"\\r\\n\", $string);\n\n        \/\/ first line must be Method\/Uri\/Version string\n        $matches   = null;\n        $methods   = $allowCustomMethods\n            ? '[\\w-]+'\n            : implode(\n                '|',\n                [\n                    self::METHOD_OPTIONS,\n                    self::METHOD_GET,\n                    self::METHOD_HEAD,\n                    self::METHOD_POST,\n                    self::METHOD_PUT,\n                    self::METHOD_DELETE,\n                    self::METHOD_TRACE,\n                    self::METHOD_CONNECT,\n                    self::METHOD_PATCH\n                ]\n            );\n\n        $regex     = '#^(?P<method>' . $methods . ')\\s(?P<uri>[^ ]*)(?:\\sHTTP\\\/(?P<version>\\d+\\.\\d+)){0,1}#';\n        $firstLine = array_shift($lines);\n        if (!preg_match($regex, $firstLine, $matches)) {\n            throw new Exception\\InvalidArgumentException(\n                'A valid request line was not found in the provided string'\n            );\n        }\n\n        $request->setMethod($matches['method']);\n        $request->setUri($matches['uri']);\n\n        $parsedUri = parse_url($matches['uri']);\n        if (array_key_exists('query', $parsedUri)) {\n            $parsedQuery = [];\n            parse_str($parsedUri['query'], $parsedQuery);\n            $request->setQuery(new Parameters($parsedQuery));\n        }\n\n        if (isset($matches['version'])) {\n            $request->setVersion($matches['version']);\n        }\n\n        if (count($lines) == 0) {\n            return $request;\n        }\n\n        $isHeader = true;\n        $headers = $rawBody = [];\n        while ($lines) {\n            $nextLine = array_shift($lines);\n            if ($nextLine == '') {\n                $isHeader = false;\n                continue;\n            }\n\n            if ($isHeader) {\n                if (preg_match(\"\/[\\r\\n]\/\", $nextLine)) {\n                    throw new Exception\\RuntimeException('CRLF injection detected');\n                }\n                $headers[] = $nextLine;\n                continue;\n            }\n\n\n            if (empty($rawBody)\n                && preg_match('\/^[a-z0-9!#$%&\\'*+.^_`|~-]+:$\/i', $nextLine)\n            ) {\n                throw new Exception\\RuntimeException('CRLF injection detected');\n            }\n\n            $rawBody[] = $nextLine;\n        }\n\n        if ($headers) {\n            $request->headers = implode(\"\\r\\n\", $headers);\n        }\n\n        if ($rawBody) {\n            $request->setContent(implode(\"\\r\\n\", $rawBody));\n        }\n\n        return $request;\n    }\n\n    \/**\n     * Set the method for this request\n     *\n     * @param  string $method\n     * @return Request\n     * @throws Exception\\InvalidArgumentException\n     *\/\n    public function setMethod($method)\n    {\n        $method = strtoupper($method);\n        if (!defined('static::METHOD_' . $method) && ! $this->getAllowCustomMethods()) {\n            throw new Exception\\InvalidArgumentException('Invalid HTTP method passed');\n        }\n        $this->method = $method;\n        return $this;\n    }\n\n    \/**\n     * Return the method for this request\n     *\n     * @return string\n     *\/\n    public function getMethod()\n    {\n        return $this->method;\n    }\n\n    \/**\n     * Set the URI\/URL for this request, this can be a string or an instance of Zend\\Uri\\Http\n     *\n     * @throws Exception\\InvalidArgumentException\n     * @param string|HttpUri $uri\n     * @return Request\n     *\/\n    public function setUri($uri)\n    {\n        if (is_string($uri)) {\n            try {\n                $uri = new HttpUri($uri);\n            } catch (UriException\\InvalidUriPartException $e) {\n                throw new Exception\\InvalidArgumentException(\n                    sprintf('Invalid URI passed as string (%s)', (string) $uri),\n                    $e->getCode(),\n                    $e\n                );\n            }\n        } elseif (!($uri instanceof HttpUri)) {\n            throw new Exception\\InvalidArgumentException(\n                'URI must be an instance of Zend\\Uri\\Http or a string'\n            );\n        }\n        $this->uri = $uri;\n\n        return $this;\n    }\n\n    \/**\n     * Return the URI for this request object\n     *\n     * @return HttpUri\n     *\/\n    public function getUri()\n    {\n        if ($this->uri === null || is_string($this->uri)) {\n            $this->uri = new HttpUri($this->uri);\n        }\n        return $this->uri;\n    }\n\n    \/**\n     * Return the URI for this request object as a string\n     *\n     * @return string\n     *\/\n    public function getUriString()\n    {\n        if ($this->uri instanceof HttpUri) {\n            return $this->uri->toString();\n        }\n        return $this->uri;\n    }\n\n    \/**\n     * Provide an alternate Parameter Container implementation for query parameters in this object,\n     * (this is NOT the primary API for value setting, for that see getQuery())\n     *\n     * @param \\Zend\\Stdlib\\ParametersInterface $query\n     * @return Request\n     *\/\n    public function setQuery(ParametersInterface $query)\n    {\n        $this->queryParams = $query;\n        return $this;\n    }\n\n    \/**\n     * Return the parameter container responsible for query parameters or a single query parameter\n     *\n     * @param string|null           $name            Parameter name to retrieve, or null to get the whole container.\n     * @param mixed|null            $default         Default value to use when the parameter is missing.\n     * @return \\Zend\\Stdlib\\ParametersInterface|mixed\n     *\/\n    public function getQuery($name = null, $default = null)\n    {\n        if ($this->queryParams === null) {\n            $this->queryParams = new Parameters();\n        }\n\n        if ($name === null) {\n            return $this->queryParams;\n        }\n\n        return $this->queryParams->get($name, $default);\n    }\n\n    \/**\n     * Provide an alternate Parameter Container implementation for post parameters in this object,\n     * (this is NOT the primary API for value setting, for that see getPost())\n     *\n     * @param \\Zend\\Stdlib\\ParametersInterface $post\n     * @return Request\n     *\/\n    public function setPost(ParametersInterface $post)\n    {\n        $this->postParams = $post;\n        return $this;\n    }\n\n    \/**\n     * Return the parameter container responsible for post parameters or a single post parameter.\n     *\n     * @param string|null           $name            Parameter name to retrieve, or null to get the whole container.\n     * @param mixed|null            $default         Default value to use when the parameter is missing.\n     * @return \\Zend\\Stdlib\\ParametersInterface|mixed\n     *\/\n    public function getPost($name = null, $default = null)\n    {\n        if ($this->postParams === null) {\n            $this->postParams = new Parameters();\n        }\n\n        if ($name === null) {\n            return $this->postParams;\n        }\n\n        return $this->postParams->get($name, $default);\n    }\n\n    \/**\n     * Return the Cookie header, this is the same as calling $request->getHeaders()->get('Cookie');\n     *\n     * @convenience $request->getHeaders()->get('Cookie');\n     * @return Header\\Cookie|bool\n     *\/\n    public function getCookie()\n    {\n        return $this->getHeaders()->get('Cookie');\n    }\n\n    \/**\n     * Provide an alternate Parameter Container implementation for file parameters in this object,\n     * (this is NOT the primary API for value setting, for that see getFiles())\n     *\n     * @param  ParametersInterface $files\n     * @return Request\n     *\/\n    public function setFiles(ParametersInterface $files)\n    {\n        $this->fileParams = $files;\n        return $this;\n    }\n\n    \/**\n     * Return the parameter container responsible for file parameters or a single file.\n     *\n     * @param string|null           $name            Parameter name to retrieve, or null to get the whole container.\n     * @param mixed|null            $default         Default value to use when the parameter is missing.\n     * @return ParametersInterface|mixed\n     *\/\n    public function getFiles($name = null, $default = null)\n    {\n        if ($this->fileParams === null) {\n            $this->fileParams = new Parameters();\n        }\n\n        if ($name === null) {\n            return $this->fileParams;\n        }\n\n        return $this->fileParams->get($name, $default);\n    }\n\n    \/**\n     * Return the header container responsible for headers or all headers of a certain name\/type\n     *\n     * @see \\Zend\\Http\\Headers::get()\n     * @param string|null           $name            Header name to retrieve, or null to get the whole container.\n     * @param mixed|null            $default         Default value to use when the requested header is missing.\n     * @return \\Zend\\Http\\Headers|bool|\\Zend\\Http\\Header\\HeaderInterface|\\ArrayIterator\n     *\/\n    public function getHeaders($name = null, $default = false)\n    {\n        if ($this->headers === null || is_string($this->headers)) {\n            \/\/ this is only here for fromString lazy loading\n            $this->headers = (is_string($this->headers)) ? Headers::fromString($this->headers) : new Headers();\n        }\n\n        if ($name === null) {\n            return $this->headers;\n        }\n\n        if ($this->headers->has($name)) {\n            return $this->headers->get($name);\n        }\n\n        return $default;\n    }\n\n    \/**\n     * Get all headers of a certain name\/type.\n     *\n     * @see Request::getHeaders()\n     * @param string|null           $name            Header name to retrieve, or null to get the whole container.\n     * @param mixed|null            $default         Default value to use when the requested header is missing.\n     * @return \\Zend\\Http\\Headers|bool|\\Zend\\Http\\Header\\HeaderInterface|\\ArrayIterator\n     *\/\n    public function getHeader($name, $default = false)\n    {\n        return $this->getHeaders($name, $default);\n    }\n\n    \/**\n     * Is this an OPTIONS method request?\n     *\n     * @return bool\n     *\/\n    public function isOptions()\n    {\n        return ($this->method === self::METHOD_OPTIONS);\n    }\n\n    \/**\n     * Is this a PROPFIND method request?\n     *\n     * @return bool\n     *\/\n    public function isPropFind()\n    {\n        return ($this->method === self::METHOD_PROPFIND);\n    }\n\n    \/**\n     * Is this a GET method request?\n     *\n     * @return bool\n     *\/\n    public function isGet()\n    {\n        return ($this->method === self::METHOD_GET);\n    }\n\n    \/**\n     * Is this a HEAD method request?\n     *\n     * @return bool\n     *\/\n    public function isHead()\n    {\n        return ($this->method === self::METHOD_HEAD);\n    }\n\n    \/**\n     * Is this a POST method request?\n     *\n     * @return bool\n     *\/\n    public function isPost()\n    {\n        return ($this->method === self::METHOD_POST);\n    }\n\n    \/**\n     * Is this a PUT method request?\n     *\n     * @return bool\n     *\/\n    public function isPut()\n    {\n        return ($this->method === self::METHOD_PUT);\n    }\n\n    \/**\n     * Is this a DELETE method request?\n     *\n     * @return bool\n     *\/\n    public function isDelete()\n    {\n        return ($this->method === self::METHOD_DELETE);\n    }\n\n    \/**\n     * Is this a TRACE method request?\n     *\n     * @return bool\n     *\/\n    public function isTrace()\n    {\n        return ($this->method === self::METHOD_TRACE);\n    }\n\n    \/**\n     * Is this a CONNECT method request?\n     *\n     * @return bool\n     *\/\n    public function isConnect()\n    {\n        return ($this->method === self::METHOD_CONNECT);\n    }\n\n    \/**\n     * Is this a PATCH method request?\n     *\n     * @return bool\n     *\/\n    public function isPatch()\n    {\n        return ($this->method === self::METHOD_PATCH);\n    }\n\n    \/**\n     * Is the request a Javascript XMLHttpRequest?\n     *\n     * Should work with Prototype\/Script.aculo.us, possibly others.\n     *\n     * @return bool\n     *\/\n    public function isXmlHttpRequest()\n    {\n        $header = $this->getHeaders()->get('X_REQUESTED_WITH');\n        return false !== $header && $header->getFieldValue() == 'XMLHttpRequest';\n    }\n\n    \/**\n     * Is this a Flash request?\n     *\n     * @return bool\n     *\/\n    public function isFlashRequest()\n    {\n        $header = $this->getHeaders()->get('USER_AGENT');\n        return false !== $header && stristr($header->getFieldValue(), ' flash');\n    }\n\n    \/**\n     * Return the formatted request line (first line) for this http request\n     *\n     * @return string\n     *\/\n    public function renderRequestLine()\n    {\n        return $this->method . ' ' . (string) $this->uri . ' HTTP\/' . $this->version;\n    }\n\n    \/**\n     * @return string\n     *\/\n    public function toString()\n    {\n        $str = $this->renderRequestLine() . \"\\r\\n\";\n        $str .= $this->getHeaders()->toString();\n        $str .= \"\\r\\n\";\n        $str .= $this->getContent();\n        return $str;\n    }\n\n    \/**\n     * @return boolean\n     *\/\n    public function getAllowCustomMethods()\n    {\n        return $this->allowCustomMethods;\n    }\n\n    \/**\n     * @param boolean $strictMethods\n     *\/\n    public function setAllowCustomMethods($strictMethods)\n    {\n        $this->allowCustomMethods = (bool) $strictMethods;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,0,null,0,0,0,null,0,0,0,0,0,0,0,0,null,0,0,null,0,0,0,0,null,0,null,null,0,0,null,0,0,0,0,0,0,null,0,0,0,null,0,0,null,null,0,0,0,0,0,0,0,null,null,0,0,0,null,0,0,null,null,null,0,0,0,0,null,null,0,0,null,0,0,0,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,4,null,0,0,0,0,0,null,0,null,4,0,null,0,null,4,null,4,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,4,null,4,4,null,4,4,null,null,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,0,0,0,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,4,4,null]},{"name":"vendor\/zendframework\/zend-http\/src\/Response.php","source":"<?php\n\/**\n * Zend Framework (http:\/\/framework.zend.com\/)\n *\n * @link      http:\/\/github.com\/zendframework\/zf2 for the canonical source repository\n * @copyright Copyright (c) 2005-2015 Zend Technologies USA Inc. (http:\/\/www.zend.com)\n * @license   http:\/\/framework.zend.com\/license\/new-bsd New BSD License\n *\/\n\nnamespace Zend\\Http;\n\nuse Zend\\Stdlib\\ErrorHandler;\nuse Zend\\Stdlib\\ResponseInterface;\n\n\/**\n * HTTP Response\n *\n * @link      http:\/\/www.w3.org\/Protocols\/rfc2616\/rfc2616-sec6.html#sec6\n *\/\nclass Response extends AbstractMessage implements ResponseInterface\n{\n    \/**#@+\n     * @const int Status codes\n     *\/\n    const STATUS_CODE_CUSTOM = 0;\n    const STATUS_CODE_100 = 100;\n    const STATUS_CODE_101 = 101;\n    const STATUS_CODE_102 = 102;\n    const STATUS_CODE_200 = 200;\n    const STATUS_CODE_201 = 201;\n    const STATUS_CODE_202 = 202;\n    const STATUS_CODE_203 = 203;\n    const STATUS_CODE_204 = 204;\n    const STATUS_CODE_205 = 205;\n    const STATUS_CODE_206 = 206;\n    const STATUS_CODE_207 = 207;\n    const STATUS_CODE_208 = 208;\n    const STATUS_CODE_300 = 300;\n    const STATUS_CODE_301 = 301;\n    const STATUS_CODE_302 = 302;\n    const STATUS_CODE_303 = 303;\n    const STATUS_CODE_304 = 304;\n    const STATUS_CODE_305 = 305;\n    const STATUS_CODE_306 = 306;\n    const STATUS_CODE_307 = 307;\n    const STATUS_CODE_400 = 400;\n    const STATUS_CODE_401 = 401;\n    const STATUS_CODE_402 = 402;\n    const STATUS_CODE_403 = 403;\n    const STATUS_CODE_404 = 404;\n    const STATUS_CODE_405 = 405;\n    const STATUS_CODE_406 = 406;\n    const STATUS_CODE_407 = 407;\n    const STATUS_CODE_408 = 408;\n    const STATUS_CODE_409 = 409;\n    const STATUS_CODE_410 = 410;\n    const STATUS_CODE_411 = 411;\n    const STATUS_CODE_412 = 412;\n    const STATUS_CODE_413 = 413;\n    const STATUS_CODE_414 = 414;\n    const STATUS_CODE_415 = 415;\n    const STATUS_CODE_416 = 416;\n    const STATUS_CODE_417 = 417;\n    const STATUS_CODE_418 = 418;\n    const STATUS_CODE_422 = 422;\n    const STATUS_CODE_423 = 423;\n    const STATUS_CODE_424 = 424;\n    const STATUS_CODE_425 = 425;\n    const STATUS_CODE_426 = 426;\n    const STATUS_CODE_428 = 428;\n    const STATUS_CODE_429 = 429;\n    const STATUS_CODE_431 = 431;\n    const STATUS_CODE_500 = 500;\n    const STATUS_CODE_501 = 501;\n    const STATUS_CODE_502 = 502;\n    const STATUS_CODE_503 = 503;\n    const STATUS_CODE_504 = 504;\n    const STATUS_CODE_505 = 505;\n    const STATUS_CODE_506 = 506;\n    const STATUS_CODE_507 = 507;\n    const STATUS_CODE_508 = 508;\n    const STATUS_CODE_511 = 511;\n    \/**#@-*\/\n\n    \/**\n     * @var array Recommended Reason Phrases\n     *\/\n    protected $recommendedReasonPhrases = [\n        \/\/ INFORMATIONAL CODES\n        100 => 'Continue',\n        101 => 'Switching Protocols',\n        102 => 'Processing',\n        \/\/ SUCCESS CODES\n        200 => 'OK',\n        201 => 'Created',\n        202 => 'Accepted',\n        203 => 'Non-Authoritative Information',\n        204 => 'No Content',\n        205 => 'Reset Content',\n        206 => 'Partial Content',\n        207 => 'Multi-status',\n        208 => 'Already Reported',\n        \/\/ REDIRECTION CODES\n        300 => 'Multiple Choices',\n        301 => 'Moved Permanently',\n        302 => 'Found',\n        303 => 'See Other',\n        304 => 'Not Modified',\n        305 => 'Use Proxy',\n        306 => 'Switch Proxy', \/\/ Deprecated\n        307 => 'Temporary Redirect',\n        \/\/ CLIENT ERROR\n        400 => 'Bad Request',\n        401 => 'Unauthorized',\n        402 => 'Payment Required',\n        403 => 'Forbidden',\n        404 => 'Not Found',\n        405 => 'Method Not Allowed',\n        406 => 'Not Acceptable',\n        407 => 'Proxy Authentication Required',\n        408 => 'Request Time-out',\n        409 => 'Conflict',\n        410 => 'Gone',\n        411 => 'Length Required',\n        412 => 'Precondition Failed',\n        413 => 'Request Entity Too Large',\n        414 => 'Request-URI Too Long',\n        415 => 'Unsupported Media Type',\n        416 => 'Requested range not satisfiable',\n        417 => 'Expectation Failed',\n        418 => 'I\\'m a teapot',\n        422 => 'Unprocessable Entity',\n        423 => 'Locked',\n        424 => 'Failed Dependency',\n        425 => 'Unordered Collection',\n        426 => 'Upgrade Required',\n        428 => 'Precondition Required',\n        429 => 'Too Many Requests',\n        431 => 'Request Header Fields Too Large',\n        \/\/ SERVER ERROR\n        500 => 'Internal Server Error',\n        501 => 'Not Implemented',\n        502 => 'Bad Gateway',\n        503 => 'Service Unavailable',\n        504 => 'Gateway Time-out',\n        505 => 'HTTP Version not supported',\n        506 => 'Variant Also Negotiates',\n        507 => 'Insufficient Storage',\n        508 => 'Loop Detected',\n        511 => 'Network Authentication Required',\n    ];\n\n    \/**\n     * @var int Status code\n     *\/\n    protected $statusCode = 200;\n\n    \/**\n     * @var string|null Null means it will be looked up from the $reasonPhrase list above\n     *\/\n    protected $reasonPhrase = null;\n\n    \/**\n     * Populate object from string\n     *\n     * @param  string $string\n     * @return self\n     * @throws Exception\\InvalidArgumentException\n     *\/\n    public static function fromString($string)\n    {\n        $lines = explode(\"\\r\\n\", $string);\n        if (!is_array($lines) || count($lines) == 1) {\n            $lines = explode(\"\\n\", $string);\n        }\n\n        $firstLine = array_shift($lines);\n\n        $response = new static();\n\n        $regex   = '\/^HTTP\\\/(?P<version>1\\.[01]) (?P<status>\\d{3})(?:[ ]+(?P<reason>.*))?$\/';\n        $matches = [];\n        if (!preg_match($regex, $firstLine, $matches)) {\n            throw new Exception\\InvalidArgumentException(\n                'A valid response status line was not found in the provided string'\n            );\n        }\n\n        $response->version = $matches['version'];\n        $response->setStatusCode($matches['status']);\n        $response->setReasonPhrase((isset($matches['reason']) ? $matches['reason'] : ''));\n\n        if (count($lines) == 0) {\n            return $response;\n        }\n\n        $isHeader = true;\n        $headers = $content = [];\n\n        foreach ($lines as $line) {\n            if ($isHeader && $line == '') {\n                $isHeader = false;\n                continue;\n            }\n\n            if ($isHeader) {\n                if (preg_match(\"\/[\\r\\n]\/\", $line)) {\n                    throw new Exception\\RuntimeException('CRLF injection detected');\n                }\n                $headers[] = $line;\n                continue;\n            }\n\n            if (empty($content)\n                && preg_match('\/^[a-z0-9!#$%&\\'*+.^_`|~-]+:$\/i', $line)\n            ) {\n                throw new Exception\\RuntimeException('CRLF injection detected');\n            }\n\n            $content[] = $line;\n        }\n\n        if ($headers) {\n            $response->headers = implode(\"\\r\\n\", $headers);\n        }\n\n        if ($content) {\n            $response->setContent(implode(\"\\r\\n\", $content));\n        }\n\n        return $response;\n    }\n\n    \/**\n     * @return Header\\SetCookie[]\n     *\/\n    public function getCookie()\n    {\n        return $this->getHeaders()->get('Set-Cookie');\n    }\n\n    \/**\n     * Set HTTP status code and (optionally) message\n     *\n     * @param  int $code\n     * @throws Exception\\InvalidArgumentException\n     * @return self\n     *\/\n    public function setStatusCode($code)\n    {\n        $const = get_class($this) . '::STATUS_CODE_' . $code;\n        if (!is_numeric($code) || !defined($const)) {\n            $code = is_scalar($code) ? $code : gettype($code);\n            throw new Exception\\InvalidArgumentException(sprintf(\n                'Invalid status code provided: \"%s\"',\n                $code\n            ));\n        }\n\n        return $this->saveStatusCode($code);\n    }\n\n    \/**\n     * Retrieve HTTP status code\n     *\n     * @return int\n     *\/\n    public function getStatusCode()\n    {\n        return $this->statusCode;\n    }\n\n    \/**\n     * Set custom HTTP status code\n     *\n     * @param  int $code\n     * @throws Exception\\InvalidArgumentException\n     * @return self\n     *\/\n    public function setCustomStatusCode($code)\n    {\n        if (!is_numeric($code)) {\n            $code = is_scalar($code) ? $code : gettype($code);\n            throw new Exception\\InvalidArgumentException(sprintf(\n                'Invalid status code provided: \"%s\"',\n                $code\n            ));\n        }\n\n        return $this->saveStatusCode($code);\n    }\n\n    \/**\n     * Assign status code\n     *\n     * @param int $code\n     * @return self\n     *\/\n    protected function saveStatusCode($code)\n    {\n        $this->reasonPhrase = null;\n        $this->statusCode = (int) $code;\n        return $this;\n    }\n\n    \/**\n     * @param string $reasonPhrase\n     * @return self\n     *\/\n    public function setReasonPhrase($reasonPhrase)\n    {\n        $this->reasonPhrase = trim($reasonPhrase);\n        return $this;\n    }\n\n    \/**\n     * Get HTTP status message\n     *\n     * @return string\n     *\/\n    public function getReasonPhrase()\n    {\n        if (null == $this->reasonPhrase and isset($this->recommendedReasonPhrases[$this->statusCode])) {\n            $this->reasonPhrase = $this->recommendedReasonPhrases[$this->statusCode];\n        }\n        return $this->reasonPhrase;\n    }\n\n    \/**\n     * Get the body of the response\n     *\n     * @return string\n     *\/\n    public function getBody()\n    {\n        $body = (string) $this->getContent();\n\n        $transferEncoding = $this->getHeaders()->get('Transfer-Encoding');\n\n        if (!empty($transferEncoding)) {\n            if (strtolower($transferEncoding->getFieldValue()) == 'chunked') {\n                $body = $this->decodeChunkedBody($body);\n            }\n        }\n\n        $contentEncoding = $this->getHeaders()->get('Content-Encoding');\n\n        if (!empty($contentEncoding)) {\n            $contentEncoding = $contentEncoding->getFieldValue();\n            if ($contentEncoding =='gzip') {\n                $body = $this->decodeGzip($body);\n            } elseif ($contentEncoding == 'deflate') {\n                $body = $this->decodeDeflate($body);\n            }\n        }\n\n        return $body;\n    }\n\n    \/**\n     * Does the status code indicate a client error?\n     *\n     * @return bool\n     *\/\n    public function isClientError()\n    {\n        $code = $this->getStatusCode();\n        return ($code < 500 && $code >= 400);\n    }\n\n    \/**\n     * Is the request forbidden due to ACLs?\n     *\n     * @return bool\n     *\/\n    public function isForbidden()\n    {\n        return (403 == $this->getStatusCode());\n    }\n\n    \/**\n     * Is the current status \"informational\"?\n     *\n     * @return bool\n     *\/\n    public function isInformational()\n    {\n        $code = $this->getStatusCode();\n        return ($code >= 100 && $code < 200);\n    }\n\n    \/**\n     * Does the status code indicate the resource is not found?\n     *\n     * @return bool\n     *\/\n    public function isNotFound()\n    {\n        return (404 === $this->getStatusCode());\n    }\n\n    \/**\n     * Do we have a normal, OK response?\n     *\n     * @return bool\n     *\/\n    public function isOk()\n    {\n        return (200 === $this->getStatusCode());\n    }\n\n    \/**\n     * Does the status code reflect a server error?\n     *\n     * @return bool\n     *\/\n    public function isServerError()\n    {\n        $code = $this->getStatusCode();\n        return (500 <= $code && 600 > $code);\n    }\n\n    \/**\n     * Do we have a redirect?\n     *\n     * @return bool\n     *\/\n    public function isRedirect()\n    {\n        $code = $this->getStatusCode();\n        return (300 <= $code && 400 > $code);\n    }\n\n    \/**\n     * Was the response successful?\n     *\n     * @return bool\n     *\/\n    public function isSuccess()\n    {\n        $code = $this->getStatusCode();\n        return (200 <= $code && 300 > $code);\n    }\n\n    \/**\n     * Render the status line header\n     *\n     * @return string\n     *\/\n    public function renderStatusLine()\n    {\n        $status = sprintf(\n            'HTTP\/%s %d %s',\n            $this->getVersion(),\n            $this->getStatusCode(),\n            $this->getReasonPhrase()\n        );\n        return trim($status);\n    }\n\n    \/**\n     * Render entire response as HTTP response string\n     *\n     * @return string\n     *\/\n    public function toString()\n    {\n        $str  = $this->renderStatusLine() . \"\\r\\n\";\n        $str .= $this->getHeaders()->toString();\n        $str .= \"\\r\\n\";\n        $str .= $this->getContent();\n        return $str;\n    }\n\n    \/**\n     * Decode a \"chunked\" transfer-encoded body and return the decoded text\n     *\n     * @param  string $body\n     * @return string\n     * @throws Exception\\RuntimeException\n     *\/\n    protected function decodeChunkedBody($body)\n    {\n        $decBody = '';\n\n        while (trim($body)) {\n            if (! preg_match(\"\/^([\\da-fA-F]+)[^\\r\\n]*\\r\\n\/sm\", $body, $m)) {\n                throw new Exception\\RuntimeException(\n                    \"Error parsing body - doesn't seem to be a chunked message\"\n                );\n            }\n\n            $length   = hexdec(trim($m[1]));\n            $cut      = strlen($m[0]);\n            $decBody .= substr($body, $cut, $length);\n            $body     = substr($body, $cut + $length + 2);\n        }\n\n        return $decBody;\n    }\n\n    \/**\n     * Decode a gzip encoded message (when Content-encoding = gzip)\n     *\n     * Currently requires PHP with zlib support\n     *\n     * @param  string $body\n     * @return string\n     * @throws Exception\\RuntimeException\n     *\/\n    protected function decodeGzip($body)\n    {\n        if (!function_exists('gzinflate')) {\n            throw new Exception\\RuntimeException(\n                'zlib extension is required in order to decode \"gzip\" encoding'\n            );\n        }\n\n        ErrorHandler::start();\n        $return = gzinflate(substr($body, 10));\n        $test = ErrorHandler::stop();\n        if ($test) {\n            throw new Exception\\RuntimeException(\n                'Error occurred during gzip inflation',\n                0,\n                $test\n            );\n        }\n        return $return;\n    }\n\n    \/**\n     * Decode a zlib deflated message (when Content-encoding = deflate)\n     *\n     * Currently requires PHP with zlib support\n     *\n     * @param  string $body\n     * @return string\n     * @throws Exception\\RuntimeException\n     *\/\n    protected function decodeDeflate($body)\n    {\n        if (!function_exists('gzuncompress')) {\n            throw new Exception\\RuntimeException(\n                'zlib extension is required in order to decode \"deflate\" encoding'\n            );\n        }\n\n        \/**\n         * Some servers (IIS ?) send a broken deflate response, without the\n         * RFC-required zlib header.\n         *\n         * We try to detect the zlib header, and if it does not exist we\n         * teat the body is plain DEFLATE content.\n         *\n         * This method was adapted from PEAR HTTP_Request2 by (c) Alexey Borzov\n         *\n         * @link http:\/\/framework.zend.com\/issues\/browse\/ZF-6040\n         *\/\n        $zlibHeader = unpack('n', substr($body, 0, 2));\n\n        if ($zlibHeader[1] % 31 == 0) {\n            return gzuncompress($body);\n        }\n        return gzinflate($body);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,0,null,0,null,0,0,0,0,null,0,null,null,0,0,0,null,0,0,null,null,0,0,null,0,0,0,0,null,null,0,0,0,null,0,0,null,null,0,0,0,0,null,null,0,0,null,0,0,0,null,0,0,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,0,0,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,null,null,null,null,null,null,null,0,null,0,null,0,0,0,0,0,null,0,null,0,0,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,0,null,null,null,null,null,null,null,null,null,0,0,0,0,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,0,null,0,null,null,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,0,0,0,0,0,0,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,null,0,null,null]},{"name":"vendor\/zendframework\/zend-stdlib\/src\/ArrayObject.php","source":"<?php\n\/**\n * Zend Framework (http:\/\/framework.zend.com\/)\n *\n * @link      http:\/\/github.com\/zendframework\/zf2 for the canonical source repository\n * @copyright Copyright (c) 2005-2015 Zend Technologies USA Inc. (http:\/\/www.zend.com)\n * @license   http:\/\/framework.zend.com\/license\/new-bsd New BSD License\n *\/\n\nnamespace Zend\\Stdlib;\n\nuse ArrayAccess;\nuse Countable;\nuse IteratorAggregate;\nuse Serializable;\n\n\/**\n * Custom framework ArrayObject implementation\n *\n * Extends version-specific \"abstract\" implementation.\n *\/\nclass ArrayObject implements IteratorAggregate, ArrayAccess, Serializable, Countable\n{\n    \/**\n     * Properties of the object have their normal functionality\n     * when accessed as list (var_dump, foreach, etc.).\n     *\/\n    const STD_PROP_LIST = 1;\n\n    \/**\n     * Entries can be accessed as properties (read and write).\n     *\/\n    const ARRAY_AS_PROPS = 2;\n\n    \/**\n     * @var array\n     *\/\n    protected $storage;\n\n    \/**\n     * @var int\n     *\/\n    protected $flag;\n\n    \/**\n     * @var string\n     *\/\n    protected $iteratorClass;\n\n    \/**\n     * @var array\n     *\/\n    protected $protectedProperties;\n\n    \/**\n     * Constructor\n     *\n     * @param array  $input\n     * @param int    $flags\n     * @param string $iteratorClass\n     *\/\n    public function __construct($input = [], $flags = self::STD_PROP_LIST, $iteratorClass = 'ArrayIterator')\n    {\n        $this->setFlags($flags);\n        $this->storage = $input;\n        $this->setIteratorClass($iteratorClass);\n        $this->protectedProperties = array_keys(get_object_vars($this));\n    }\n\n    \/**\n     * Returns whether the requested key exists\n     *\n     * @param  mixed $key\n     * @return bool\n     *\/\n    public function __isset($key)\n    {\n        if ($this->flag == self::ARRAY_AS_PROPS) {\n            return $this->offsetExists($key);\n        }\n        if (in_array($key, $this->protectedProperties)) {\n            throw new Exception\\InvalidArgumentException('$key is a protected property, use a different key');\n        }\n\n        return isset($this->$key);\n    }\n\n    \/**\n     * Sets the value at the specified key to value\n     *\n     * @param  mixed $key\n     * @param  mixed $value\n     * @return void\n     *\/\n    public function __set($key, $value)\n    {\n        if ($this->flag == self::ARRAY_AS_PROPS) {\n            return $this->offsetSet($key, $value);\n        }\n        if (in_array($key, $this->protectedProperties)) {\n            throw new Exception\\InvalidArgumentException('$key is a protected property, use a different key');\n        }\n        $this->$key = $value;\n    }\n\n    \/**\n     * Unsets the value at the specified key\n     *\n     * @param  mixed $key\n     * @return void\n     *\/\n    public function __unset($key)\n    {\n        if ($this->flag == self::ARRAY_AS_PROPS) {\n            return $this->offsetUnset($key);\n        }\n        if (in_array($key, $this->protectedProperties)) {\n            throw new Exception\\InvalidArgumentException('$key is a protected property, use a different key');\n        }\n        unset($this->$key);\n    }\n\n    \/**\n     * Returns the value at the specified key by reference\n     *\n     * @param  mixed $key\n     * @return mixed\n     *\/\n    public function &__get($key)\n    {\n        $ret = null;\n        if ($this->flag == self::ARRAY_AS_PROPS) {\n            $ret =& $this->offsetGet($key);\n\n            return $ret;\n        }\n        if (in_array($key, $this->protectedProperties)) {\n            throw new Exception\\InvalidArgumentException('$key is a protected property, use a different key');\n        }\n\n        return $this->$key;\n    }\n\n    \/**\n     * Appends the value\n     *\n     * @param  mixed $value\n     * @return void\n     *\/\n    public function append($value)\n    {\n        $this->storage[] = $value;\n    }\n\n    \/**\n     * Sort the entries by value\n     *\n     * @return void\n     *\/\n    public function asort()\n    {\n        asort($this->storage);\n    }\n\n    \/**\n     * Get the number of public properties in the ArrayObject\n     *\n     * @return int\n     *\/\n    public function count()\n    {\n        return count($this->storage);\n    }\n\n    \/**\n     * Exchange the array for another one.\n     *\n     * @param  array|ArrayObject $data\n     * @return array\n     *\/\n    public function exchangeArray($data)\n    {\n        if (!is_array($data) && !is_object($data)) {\n            throw new Exception\\InvalidArgumentException('Passed variable is not an array or object, using empty array instead');\n        }\n\n        if (is_object($data) && ($data instanceof self || $data instanceof \\ArrayObject)) {\n            $data = $data->getArrayCopy();\n        }\n        if (!is_array($data)) {\n            $data = (array) $data;\n        }\n\n        $storage = $this->storage;\n\n        $this->storage = $data;\n\n        return $storage;\n    }\n\n    \/**\n     * Creates a copy of the ArrayObject.\n     *\n     * @return array\n     *\/\n    public function getArrayCopy()\n    {\n        return $this->storage;\n    }\n\n    \/**\n     * Gets the behavior flags.\n     *\n     * @return int\n     *\/\n    public function getFlags()\n    {\n        return $this->flag;\n    }\n\n    \/**\n     * Create a new iterator from an ArrayObject instance\n     *\n     * @return \\Iterator\n     *\/\n    public function getIterator()\n    {\n        $class = $this->iteratorClass;\n\n        return new $class($this->storage);\n    }\n\n    \/**\n     * Gets the iterator classname for the ArrayObject.\n     *\n     * @return string\n     *\/\n    public function getIteratorClass()\n    {\n        return $this->iteratorClass;\n    }\n\n    \/**\n     * Sort the entries by key\n     *\n     * @return void\n     *\/\n    public function ksort()\n    {\n        ksort($this->storage);\n    }\n\n    \/**\n     * Sort an array using a case insensitive \"natural order\" algorithm\n     *\n     * @return void\n     *\/\n    public function natcasesort()\n    {\n        natcasesort($this->storage);\n    }\n\n    \/**\n     * Sort entries using a \"natural order\" algorithm\n     *\n     * @return void\n     *\/\n    public function natsort()\n    {\n        natsort($this->storage);\n    }\n\n    \/**\n     * Returns whether the requested key exists\n     *\n     * @param  mixed $key\n     * @return bool\n     *\/\n    public function offsetExists($key)\n    {\n        return isset($this->storage[$key]);\n    }\n\n    \/**\n     * Returns the value at the specified key\n     *\n     * @param  mixed $key\n     * @return mixed\n     *\/\n    public function &offsetGet($key)\n    {\n        $ret = null;\n        if (!$this->offsetExists($key)) {\n            return $ret;\n        }\n        $ret =& $this->storage[$key];\n\n        return $ret;\n    }\n\n    \/**\n     * Sets the value at the specified key to value\n     *\n     * @param  mixed $key\n     * @param  mixed $value\n     * @return void\n     *\/\n    public function offsetSet($key, $value)\n    {\n        $this->storage[$key] = $value;\n    }\n\n    \/**\n     * Unsets the value at the specified key\n     *\n     * @param  mixed $key\n     * @return void\n     *\/\n    public function offsetUnset($key)\n    {\n        if ($this->offsetExists($key)) {\n            unset($this->storage[$key]);\n        }\n    }\n\n    \/**\n     * Serialize an ArrayObject\n     *\n     * @return string\n     *\/\n    public function serialize()\n    {\n        return serialize(get_object_vars($this));\n    }\n\n    \/**\n     * Sets the behavior flags\n     *\n     * @param  int  $flags\n     * @return void\n     *\/\n    public function setFlags($flags)\n    {\n        $this->flag = $flags;\n    }\n\n    \/**\n     * Sets the iterator classname for the ArrayObject\n     *\n     * @param  string $class\n     * @return void\n     *\/\n    public function setIteratorClass($class)\n    {\n        if (class_exists($class)) {\n            $this->iteratorClass = $class;\n\n            return ;\n        }\n\n        if (strpos($class, '\\\\') === 0) {\n            $class = '\\\\' . $class;\n            if (class_exists($class)) {\n                $this->iteratorClass = $class;\n\n                return ;\n            }\n        }\n\n        throw new Exception\\InvalidArgumentException('The iterator class does not exist');\n    }\n\n    \/**\n     * Sort the entries with a user-defined comparison function and maintain key association\n     *\n     * @param  callable $function\n     * @return void\n     *\/\n    public function uasort($function)\n    {\n        if (is_callable($function)) {\n            uasort($this->storage, $function);\n        }\n    }\n\n    \/**\n     * Sort the entries by keys using a user-defined comparison function\n     *\n     * @param  callable $function\n     * @return void\n     *\/\n    public function uksort($function)\n    {\n        if (is_callable($function)) {\n            uksort($this->storage, $function);\n        }\n    }\n\n    \/**\n     * Unserialize an ArrayObject\n     *\n     * @param  string $data\n     * @return void\n     *\/\n    public function unserialize($data)\n    {\n        $ar                        = unserialize($data);\n        $this->protectedProperties = array_keys(get_object_vars($this));\n\n        $this->setFlags($ar['flag']);\n        $this->exchangeArray($ar['storage']);\n        $this->setIteratorClass($ar['iteratorClass']);\n\n        foreach ($ar as $k => $v) {\n            switch ($k) {\n                case 'flag':\n                    $this->setFlags($v);\n                    break;\n                case 'storage':\n                    $this->exchangeArray($v);\n                    break;\n                case 'iteratorClass':\n                    $this->setIteratorClass($v);\n                    break;\n                case 'protectedProperties':\n                    continue;\n                default:\n                    $this->__set($k, $v);\n            }\n        }\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,null,null,null,null,null,null,null,null,null,0,0,null,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,0,null,0,0,null,null,null,null,null,null,null,null,null,0,0,null,0,0,null,0,0,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,0,0,0,0,0,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,0,0,0,0,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,null,null,null,null,null,null,null,0,0,null,0,0,0,null,0,null,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,null]},{"name":"vendor\/zendframework\/zend-stdlib\/src\/Message.php","source":"<?php\n\/**\n * Zend Framework (http:\/\/framework.zend.com\/)\n *\n * @link      http:\/\/github.com\/zendframework\/zf2 for the canonical source repository\n * @copyright Copyright (c) 2005-2015 Zend Technologies USA Inc. (http:\/\/www.zend.com)\n * @license   http:\/\/framework.zend.com\/license\/new-bsd New BSD License\n *\/\n\nnamespace Zend\\Stdlib;\n\nuse Traversable;\n\nclass Message implements MessageInterface\n{\n    \/**\n     * @var array\n     *\/\n    protected $metadata = [];\n\n    \/**\n     * @var string\n     *\/\n    protected $content = '';\n\n    \/**\n     * Set message metadata\n     *\n     * Non-destructive setting of message metadata; always adds to the metadata, never overwrites\n     * the entire metadata container.\n     *\n     * @param  string|int|array|Traversable $spec\n     * @param  mixed $value\n     * @throws Exception\\InvalidArgumentException\n     * @return Message\n     *\/\n    public function setMetadata($spec, $value = null)\n    {\n        if (is_scalar($spec)) {\n            $this->metadata[$spec] = $value;\n            return $this;\n        }\n        if (!is_array($spec) && !$spec instanceof Traversable) {\n            throw new Exception\\InvalidArgumentException(sprintf(\n                'Expected a string, array, or Traversable argument in first position; received \"%s\"',\n                (is_object($spec) ? get_class($spec) : gettype($spec))\n            ));\n        }\n        foreach ($spec as $key => $value) {\n            $this->metadata[$key] = $value;\n        }\n        return $this;\n    }\n\n    \/**\n     * Retrieve all metadata or a single metadatum as specified by key\n     *\n     * @param  null|string|int $key\n     * @param  null|mixed $default\n     * @throws Exception\\InvalidArgumentException\n     * @return mixed\n     *\/\n    public function getMetadata($key = null, $default = null)\n    {\n        if (null === $key) {\n            return $this->metadata;\n        }\n\n        if (!is_scalar($key)) {\n            throw new Exception\\InvalidArgumentException('Non-scalar argument provided for key');\n        }\n\n        if (array_key_exists($key, $this->metadata)) {\n            return $this->metadata[$key];\n        }\n\n        return $default;\n    }\n\n    \/**\n     * Set message content\n     *\n     * @param  mixed $value\n     * @return Message\n     *\/\n    public function setContent($value)\n    {\n        $this->content = $value;\n        return $this;\n    }\n\n    \/**\n     * Get message content\n     *\n     * @return mixed\n     *\/\n    public function getContent()\n    {\n        return $this->content;\n    }\n\n    \/**\n     * @return string\n     *\/\n    public function toString()\n    {\n        $request = '';\n        foreach ($this->getMetadata() as $key => $value) {\n            $request .= sprintf(\n                \"%s: %s\\r\\n\",\n                (string) $key,\n                (string) $value\n            );\n        }\n        $request .= \"\\r\\n\" . $this->getContent();\n        return $request;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,0,0,0,0,null,0,0,0,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,0,0,0,0,null,0,0,0,0,null,null]},{"name":"vendor\/zendframework\/zend-stdlib\/src\/MessageInterface.php","source":"<?php\n\/**\n * Zend Framework (http:\/\/framework.zend.com\/)\n *\n * @link      http:\/\/github.com\/zendframework\/zf2 for the canonical source repository\n * @copyright Copyright (c) 2005-2015 Zend Technologies USA Inc. (http:\/\/www.zend.com)\n * @license   http:\/\/framework.zend.com\/license\/new-bsd New BSD License\n *\/\n\nnamespace Zend\\Stdlib;\n\ninterface MessageInterface\n{\n    \/**\n     * Set metadata\n     *\n     * @param  string|int|array|\\Traversable $spec\n     * @param  mixed $value\n     *\/\n    public function setMetadata($spec, $value = null);\n\n    \/**\n     * Get metadata\n     *\n     * @param  null|string|int $key\n     * @return mixed\n     *\/\n    public function getMetadata($key = null);\n\n    \/**\n     * Set content\n     *\n     * @param  mixed $content\n     * @return mixed\n     *\/\n    public function setContent($content);\n\n    \/**\n     * Get content\n     *\n     * @return mixed\n     *\/\n    public function getContent();\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"vendor\/zendframework\/zend-stdlib\/src\/Parameters.php","source":"<?php\n\/**\n * Zend Framework (http:\/\/framework.zend.com\/)\n *\n * @link      http:\/\/github.com\/zendframework\/zf2 for the canonical source repository\n * @copyright Copyright (c) 2005-2015 Zend Technologies USA Inc. (http:\/\/www.zend.com)\n * @license   http:\/\/framework.zend.com\/license\/new-bsd New BSD License\n *\/\n\nnamespace Zend\\Stdlib;\n\nuse ArrayObject as PhpArrayObject;\n\nclass Parameters extends PhpArrayObject implements ParametersInterface\n{\n    \/**\n     * Constructor\n     *\n     * Enforces that we have an array, and enforces parameter access to array\n     * elements.\n     *\n     * @param  array $values\n     *\/\n    public function __construct(array $values = null)\n    {\n        if (null === $values) {\n            $values = [];\n        }\n        parent::__construct($values, ArrayObject::ARRAY_AS_PROPS);\n    }\n\n    \/**\n     * Populate from native PHP array\n     *\n     * @param  array $values\n     * @return void\n     *\/\n    public function fromArray(array $values)\n    {\n        $this->exchangeArray($values);\n    }\n\n    \/**\n     * Populate from query string\n     *\n     * @param  string $string\n     * @return void\n     *\/\n    public function fromString($string)\n    {\n        $array = [];\n        parse_str($string, $array);\n        $this->fromArray($array);\n    }\n\n    \/**\n     * Serialize to native PHP array\n     *\n     * @return array\n     *\/\n    public function toArray()\n    {\n        return $this->getArrayCopy();\n    }\n\n    \/**\n     * Serialize to query string\n     *\n     * @return string\n     *\/\n    public function toString()\n    {\n        return http_build_query($this);\n    }\n\n    \/**\n     * Retrieve by key\n     *\n     * Returns null if the key does not exist.\n     *\n     * @param  string $name\n     * @return mixed\n     *\/\n    public function offsetGet($name)\n    {\n        if ($this->offsetExists($name)) {\n            return parent::offsetGet($name);\n        }\n        return;\n    }\n\n    \/**\n     * @param string $name\n     * @param mixed $default optional default value\n     * @return mixed\n     *\/\n    public function get($name, $default = null)\n    {\n        if ($this->offsetExists($name)) {\n            return parent::offsetGet($name);\n        }\n        return $default;\n    }\n\n    \/**\n     * @param string $name\n     * @param mixed $value\n     * @return Parameters\n     *\/\n    public function set($name, $value)\n    {\n        $this[$name] = $value;\n        return $this;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,0,0,4,4,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,4,0,null,4,null,null,null,null,null,null,null,null,null,0,0,null,null]},{"name":"vendor\/zendframework\/zend-stdlib\/src\/ParametersInterface.php","source":"<?php\n\/**\n * Zend Framework (http:\/\/framework.zend.com\/)\n *\n * @link      http:\/\/github.com\/zendframework\/zf2 for the canonical source repository\n * @copyright Copyright (c) 2005-2015 Zend Technologies USA Inc. (http:\/\/www.zend.com)\n * @license   http:\/\/framework.zend.com\/license\/new-bsd New BSD License\n *\/\n\nnamespace Zend\\Stdlib;\n\nuse ArrayAccess;\nuse Countable;\nuse Serializable;\nuse Traversable;\n\n\/*\n * Basically, an ArrayObject. You could simply define something like:\n *     class QueryParams extends ArrayObject implements Parameters {}\n * and have 90% of the functionality\n *\/\ninterface ParametersInterface extends ArrayAccess, Countable, Serializable, Traversable\n{\n    \/**\n     * Constructor\n     *\n     * @param array $values\n     *\/\n    public function __construct(array $values = null);\n\n    \/**\n     * From array\n     *\n     * Allow deserialization from standard array\n     *\n     * @param array $values\n     * @return mixed\n     *\/\n    public function fromArray(array $values);\n\n    \/**\n     * From string\n     *\n     * Allow deserialization from raw body; e.g., for PUT requests\n     *\n     * @param $string\n     * @return mixed\n     *\/\n    public function fromString($string);\n\n    \/**\n     * To array\n     *\n     * Allow serialization back to standard array\n     *\n     * @return mixed\n     *\/\n    public function toArray();\n\n    \/**\n     * To string\n     *\n     * Allow serialization to query format; e.g., for PUT or POST requests\n     *\n     * @return mixed\n     *\/\n    public function toString();\n\n    \/**\n     * Get\n     *\n     * @param string $name\n     * @param mixed|null $default\n     * @return mixed\n     *\/\n    public function get($name, $default = null);\n\n    \/**\n     * Set\n     *\n     * @param string $name\n     * @param mixed $value\n     * @return ParametersInterface\n     *\/\n    public function set($name, $value);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"vendor\/zendframework\/zend-stdlib\/src\/RequestInterface.php","source":"<?php\n\/**\n * Zend Framework (http:\/\/framework.zend.com\/)\n *\n * @link      http:\/\/github.com\/zendframework\/zf2 for the canonical source repository\n * @copyright Copyright (c) 2005-2015 Zend Technologies USA Inc. (http:\/\/www.zend.com)\n * @license   http:\/\/framework.zend.com\/license\/new-bsd New BSD License\n *\/\n\nnamespace Zend\\Stdlib;\n\ninterface RequestInterface extends MessageInterface\n{\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"vendor\/zendframework\/zend-stdlib\/src\/ResponseInterface.php","source":"<?php\n\/**\n * Zend Framework (http:\/\/framework.zend.com\/)\n *\n * @link      http:\/\/github.com\/zendframework\/zf2 for the canonical source repository\n * @copyright Copyright (c) 2005-2015 Zend Technologies USA Inc. (http:\/\/www.zend.com)\n * @license   http:\/\/framework.zend.com\/license\/new-bsd New BSD License\n *\/\n\nnamespace Zend\\Stdlib;\n\ninterface ResponseInterface extends MessageInterface\n{\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"vendor\/zendframework\/zend-uri\/src\/Http.php","source":"<?php\n\/**\n * Zend Framework (http:\/\/framework.zend.com\/)\n *\n * @link      http:\/\/github.com\/zendframework\/zf2 for the canonical source repository\n * @copyright Copyright (c) 2005-2015 Zend Technologies USA Inc. (http:\/\/www.zend.com)\n * @license   http:\/\/framework.zend.com\/license\/new-bsd New BSD License\n *\/\n\nnamespace Zend\\Uri;\n\n\/**\n * HTTP URI handler\n *\/\nclass Http extends Uri\n{\n    \/**\n     * @see Uri::$validSchemes\n     *\/\n    protected static $validSchemes = array(\n        'http',\n        'https'\n    );\n\n    \/**\n     * @see Uri::$defaultPorts\n     *\/\n    protected static $defaultPorts = array(\n        'http'  => 80,\n        'https' => 443,\n    );\n\n    \/**\n     * @see Uri::$validHostTypes\n     *\/\n    protected $validHostTypes = self::HOST_DNS_OR_IPV4_OR_IPV6_OR_REGNAME;\n\n    \/**\n     * User name as provided in authority of URI\n     * @var null|string\n     *\/\n    protected $user;\n\n    \/**\n     * Password as provided in authority of URI\n     * @var null|string\n     *\/\n    protected $password;\n\n    \/**\n     * Get the username part (before the ':') of the userInfo URI part\n     *\n     * @return string|null\n     *\/\n    public function getUser()\n    {\n        return $this->user;\n    }\n\n    \/**\n     * Get the password part (after the ':') of the userInfo URI part\n     *\n     * @return string|null\n     *\/\n    public function getPassword()\n    {\n        return $this->password;\n    }\n\n    \/**\n     * Get the User-info (usually user:password) part\n     *\n     * @return string|null\n     *\/\n    public function getUserInfo()\n    {\n        return $this->userInfo;\n    }\n\n    \/**\n     * Set the username part (before the ':') of the userInfo URI part\n     *\n     * @param string|null $user\n     *\n     * @return self\n     *\/\n    public function setUser($user)\n    {\n        $this->user = null === $user ? null : (string) $user;\n\n        $this->buildUserInfo();\n\n        return $this;\n    }\n\n    \/**\n     * Set the password part (after the ':') of the userInfo URI part\n     *\n     * @param  string $password\n     *\n     * @return self\n     *\/\n    public function setPassword($password)\n    {\n        $this->password = null === $password ? null : (string) $password;\n\n        $this->buildUserInfo();\n\n        return $this;\n    }\n\n    \/**\n     * Set the URI User-info part (usually user:password)\n     *\n     * @param  string|null $userInfo\n     *\n     * @return self\n     *\n     * @throws Exception\\InvalidUriPartException If the schema definition does not have this part\n     *\/\n    public function setUserInfo($userInfo)\n    {\n        $this->userInfo = null === $userInfo ? null : (string) $userInfo;\n\n        $this->parseUserInfo();\n\n        return $this;\n    }\n\n    \/**\n     * Validate the host part of an HTTP URI\n     *\n     * This overrides the common URI validation method with a DNS or IP only\n     * default. Users may still enforce allowing other host types.\n     *\n     * @param  string  $host\n     * @param  int $allowed\n     * @return bool\n     *\/\n    public static function validateHost($host, $allowed = self::HOST_DNS_OR_IPV4_OR_IPV6)\n    {\n        return parent::validateHost($host, $allowed);\n    }\n\n    \/**\n     * Parse the user info into username and password segments\n     *\n     * Parses the user information into username and password segments, and\n     * then sets the appropriate values.\n     *\n     * @return void\n     *\/\n    protected function parseUserInfo()\n    {\n        \/\/ No user information? we're done\n        if (null === $this->userInfo) {\n            $this->setUser(null);\n            $this->setPassword(null);\n\n            return;\n        }\n\n        \/\/ If no ':' separator, we only have a username\n        if (false === strpos($this->userInfo, ':')) {\n            $this->setUser($this->userInfo);\n            $this->setPassword(null);\n            return;\n        }\n\n        \/\/ Split on the ':', and set both user and password\n        list($this->user, $this->password) = explode(':', $this->userInfo, 2);\n    }\n\n    \/**\n     * Build the user info based on user and password\n     *\n     * Builds the user info based on the given user and password values\n     *\n     * @return void\n     *\/\n    protected function buildUserInfo()\n    {\n        if (null !== $this->password) {\n            $this->userInfo = $this->user . ':' . $this->password;\n        } else {\n            $this->userInfo = $this->user;\n        }\n    }\n\n    \/**\n     * Return the URI port\n     *\n     * If no port is set, will return the default port according to the scheme\n     *\n     * @return int\n     * @see    Zend\\Uri\\Uri::getPort()\n     *\/\n    public function getPort()\n    {\n        if (empty($this->port)) {\n            if (array_key_exists($this->scheme, static::$defaultPorts)) {\n                return static::$defaultPorts[$this->scheme];\n            }\n        }\n        return $this->port;\n    }\n\n    \/**\n     * Parse a URI string\n     *\n     * @param  string $uri\n     * @return Http\n     *\/\n    public function parse($uri)\n    {\n        parent::parse($uri);\n\n        if (empty($this->path)) {\n            $this->path = '\/';\n        }\n\n        return $this;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,null,null,0,0,0,0,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,0,null,null,null,null,null,null,null,null,null,null,0,null,0,0,0,null,0,null,null]},{"name":"vendor\/zendframework\/zend-uri\/src\/Uri.php","source":"<?php\n\/**\n * Zend Framework (http:\/\/framework.zend.com\/)\n *\n * @link      http:\/\/github.com\/zendframework\/zf2 for the canonical source repository\n * @copyright Copyright (c) 2005-2015 Zend Technologies USA Inc. (http:\/\/www.zend.com)\n * @license   http:\/\/framework.zend.com\/license\/new-bsd New BSD License\n *\/\n\nnamespace Zend\\Uri;\n\nuse Zend\\Escaper\\Escaper;\nuse Zend\\Validator;\n\n\/**\n * Generic URI handler\n *\/\nclass Uri implements UriInterface\n{\n    \/**\n     * Character classes defined in RFC-3986\n     *\/\n    const CHAR_UNRESERVED   = 'a-zA-Z0-9_\\-\\.~';\n    const CHAR_GEN_DELIMS   = ':\\\/\\?#\\[\\]@';\n    const CHAR_SUB_DELIMS   = '!\\$&\\'\\(\\)\\*\\+,;=';\n    const CHAR_RESERVED     = ':\\\/\\?#\\[\\]@!\\$&\\'\\(\\)\\*\\+,;=';\n    \/**\n     * Not in the spec - those characters have special meaning in urlencoded query parameters\n     *\/\n    const CHAR_QUERY_DELIMS = '!\\$\\'\\(\\)\\*\\,';\n\n    \/**\n     * Host part types represented as binary masks\n     * The binary mask consists of 5 bits in the following order:\n     * <RegName> | <DNS> | <IPvFuture> | <IPv6> | <IPv4>\n     * Place 1 or 0 in the different positions for enable or disable the part.\n     * Finally use a hexadecimal representation.\n     *\/\n    const HOST_IPV4                           = 0x01; \/\/00001\n    const HOST_IPV6                           = 0x02; \/\/00010\n    const HOST_IPVFUTURE                      = 0x04; \/\/00100\n    const HOST_IPVANY                         = 0x07; \/\/00111\n    const HOST_DNS                            = 0x08; \/\/01000\n    const HOST_DNS_OR_IPV4                    = 0x09; \/\/01001\n    const HOST_DNS_OR_IPV6                    = 0x0A; \/\/01010\n    const HOST_DNS_OR_IPV4_OR_IPV6            = 0x0B; \/\/01011\n    const HOST_DNS_OR_IPVANY                  = 0x0F; \/\/01111\n    const HOST_REGNAME                        = 0x10; \/\/10000\n    const HOST_DNS_OR_IPV4_OR_IPV6_OR_REGNAME = 0x1B; \/\/11011\n    const HOST_ALL                            = 0x1F; \/\/11111\n\n    \/**\n     * URI scheme\n     *\n     * @var string\n     *\/\n    protected $scheme;\n\n    \/**\n     * URI userInfo part (usually user:password in HTTP URLs)\n     *\n     * @var string\n     *\/\n    protected $userInfo;\n\n    \/**\n     * URI hostname\n     *\n     * @var string\n     *\/\n    protected $host;\n\n    \/**\n     * URI port\n     *\n     * @var int\n     *\/\n    protected $port;\n\n    \/**\n     * URI path\n     *\n     * @var string\n     *\/\n    protected $path;\n\n    \/**\n     * URI query string\n     *\n     * @var string\n     *\/\n    protected $query;\n\n    \/**\n     * URI fragment\n     *\n     * @var string\n     *\/\n    protected $fragment;\n\n    \/**\n     * Which host part types are valid for this URI?\n     *\n     * @var int\n     *\/\n    protected $validHostTypes = self::HOST_ALL;\n\n    \/**\n     * Array of valid schemes.\n     *\n     * Subclasses of this class that only accept specific schemes may set the\n     * list of accepted schemes here. If not empty, when setScheme() is called\n     * it will only accept the schemes listed here.\n     *\n     * @var array\n     *\/\n    protected static $validSchemes = array();\n\n    \/**\n     * List of default ports per scheme\n     *\n     * Inheriting URI classes may set this, and the normalization methods will\n     * automatically remove the port if it is equal to the default port for the\n     * current scheme\n     *\n     * @var array\n     *\/\n    protected static $defaultPorts = array();\n\n    \/**\n     * @var Escaper\n     *\/\n    protected static $escaper;\n\n    \/**\n     * Create a new URI object\n     *\n     * @param  Uri|string|null $uri\n     * @throws Exception\\InvalidArgumentException\n     *\/\n    public function __construct($uri = null)\n    {\n        if (is_string($uri)) {\n            $this->parse($uri);\n        } elseif ($uri instanceof UriInterface) {\n            \/\/ Copy constructor\n            $this->setScheme($uri->getScheme());\n            $this->setUserInfo($uri->getUserInfo());\n            $this->setHost($uri->getHost());\n            $this->setPort($uri->getPort());\n            $this->setPath($uri->getPath());\n            $this->setQuery($uri->getQuery());\n            $this->setFragment($uri->getFragment());\n        } elseif ($uri !== null) {\n            throw new Exception\\InvalidArgumentException(sprintf(\n                'Expecting a string or a URI object, received \"%s\"',\n                (is_object($uri) ? get_class($uri) : gettype($uri))\n            ));\n        }\n    }\n\n    \/**\n     * Set Escaper instance\n     *\n     * @param  Escaper $escaper\n     *\/\n    public static function setEscaper(Escaper $escaper)\n    {\n        static::$escaper = $escaper;\n    }\n\n    \/**\n     * Retrieve Escaper instance\n     *\n     * Lazy-loads one if none provided\n     *\n     * @return Escaper\n     *\/\n    public static function getEscaper()\n    {\n        if (null === static::$escaper) {\n            static::setEscaper(new Escaper());\n        }\n        return static::$escaper;\n    }\n\n    \/**\n     * Check if the URI is valid\n     *\n     * Note that a relative URI may still be valid\n     *\n     * @return bool\n     *\/\n    public function isValid()\n    {\n        if ($this->host) {\n            if (strlen($this->path) > 0 && substr($this->path, 0, 1) != '\/') {\n                return false;\n            }\n            return true;\n        }\n\n        if ($this->userInfo || $this->port) {\n            return false;\n        }\n\n        if ($this->path) {\n            \/\/ Check path-only (no host) URI\n            if (substr($this->path, 0, 2) == '\/\/') {\n                return false;\n            }\n            return true;\n        }\n\n        if (! ($this->query || $this->fragment)) {\n            \/\/ No host, path, query or fragment - this is not a valid URI\n            return false;\n        }\n\n        return true;\n    }\n\n    \/**\n     * Check if the URI is a valid relative URI\n     *\n     * @return bool\n     *\/\n    public function isValidRelative()\n    {\n        if ($this->scheme || $this->host || $this->userInfo || $this->port) {\n            return false;\n        }\n\n        if ($this->path) {\n            \/\/ Check path-only (no host) URI\n            if (substr($this->path, 0, 2) == '\/\/') {\n                return false;\n            }\n            return true;\n        }\n\n        if (! ($this->query || $this->fragment)) {\n            \/\/ No host, path, query or fragment - this is not a valid URI\n            return false;\n        }\n\n        return true;\n    }\n\n    \/**\n     * Check if the URI is an absolute or relative URI\n     *\n     * @return bool\n     *\/\n    public function isAbsolute()\n    {\n        return ($this->scheme !== null);\n    }\n\n    \/**\n     * Reset URI parts\n     *\/\n    protected function reset()\n    {\n        $this->setScheme(null);\n        $this->setPort(null);\n        $this->setUserInfo(null);\n        $this->setHost(null);\n        $this->setPath(null);\n        $this->setFragment(null);\n        $this->setQuery(null);\n    }\n\n    \/**\n     * Parse a URI string\n     *\n     * @param  string $uri\n     * @return Uri\n     *\/\n    public function parse($uri)\n    {\n        $this->reset();\n\n        \/\/ Capture scheme\n        if (($scheme = self::parseScheme($uri)) !== null) {\n            $this->setScheme($scheme);\n            $uri = substr($uri, strlen($scheme) + 1) ?: '';\n        }\n\n        \/\/ Capture authority part\n        if (preg_match('|^\/\/([^\/\\?#]*)|', $uri, $match)) {\n            $authority = $match[1];\n            $uri       = substr($uri, strlen($match[0]));\n\n            \/\/ Split authority into userInfo and host\n            if (strpos($authority, '@') !== false) {\n                \/\/ The userInfo can also contain '@' symbols; split $authority\n                \/\/ into segments, and set it to the last segment.\n                $segments  = explode('@', $authority);\n                $authority = array_pop($segments);\n                $userInfo  = implode('@', $segments);\n                unset($segments);\n                $this->setUserInfo($userInfo);\n            }\n\n            $nMatches = preg_match('\/:[\\d]{1,5}$\/', $authority, $matches);\n            if ($nMatches === 1) {\n                $portLength = strlen($matches[0]);\n                $port = substr($matches[0], 1);\n\n                $this->setPort((int) $port);\n                $authority = substr($authority, 0, -$portLength);\n            }\n\n            $this->setHost($authority);\n        }\n\n        if (!$uri) {\n            return $this;\n        }\n\n        \/\/ Capture the path\n        if (preg_match('|^[^\\?#]*|', $uri, $match)) {\n            $this->setPath($match[0]);\n            $uri = substr($uri, strlen($match[0]));\n        }\n\n        if (!$uri) {\n            return $this;\n        }\n\n        \/\/ Capture the query\n        if (preg_match('|^\\?([^#]*)|', $uri, $match)) {\n            $this->setQuery($match[1]);\n            $uri = substr($uri, strlen($match[0]));\n        }\n        if (!$uri) {\n            return $this;\n        }\n\n        \/\/ All that's left is the fragment\n        if ($uri && substr($uri, 0, 1) == '#') {\n            $this->setFragment(substr($uri, 1));\n        }\n\n        return $this;\n    }\n\n    \/**\n     * Compose the URI into a string\n     *\n     * @return string\n     * @throws Exception\\InvalidUriException\n     *\/\n    public function toString()\n    {\n        if (!$this->isValid()) {\n            if ($this->isAbsolute() || !$this->isValidRelative()) {\n                throw new Exception\\InvalidUriException(\n                    'URI is not valid and cannot be converted into a string'\n                );\n            }\n        }\n\n        $uri = '';\n\n        if ($this->scheme) {\n            $uri .= $this->scheme . ':';\n        }\n\n        if ($this->host !== null) {\n            $uri .= '\/\/';\n            if ($this->userInfo) {\n                $uri .= $this->userInfo . '@';\n            }\n            $uri .= $this->host;\n            if ($this->port) {\n                $uri .= ':' . $this->port;\n            }\n        }\n\n        if ($this->path) {\n            $uri .= static::encodePath($this->path);\n        } elseif ($this->host && ($this->query || $this->fragment)) {\n            $uri .= '\/';\n        }\n\n        if ($this->query) {\n            $uri .= \"?\" . static::encodeQueryFragment($this->query);\n        }\n\n        if ($this->fragment) {\n            $uri .= \"#\" . static::encodeQueryFragment($this->fragment);\n        }\n\n        return $uri;\n    }\n\n    \/**\n     * Normalize the URI\n     *\n     * Normalizing a URI includes removing any redundant parent directory or\n     * current directory references from the path (e.g. foo\/bar\/..\/baz becomes\n     * foo\/baz), normalizing the scheme case, decoding any over-encoded\n     * characters etc.\n     *\n     * Eventually, two normalized URLs pointing to the same resource should be\n     * equal even if they were originally represented by two different strings\n     *\n     * @return Uri\n     *\/\n    public function normalize()\n    {\n        if ($this->scheme) {\n            $this->scheme = static::normalizeScheme($this->scheme);\n        }\n\n        if ($this->host) {\n            $this->host = static::normalizeHost($this->host);\n        }\n\n        if ($this->port) {\n            $this->port = static::normalizePort($this->port, $this->scheme);\n        }\n\n        if ($this->path) {\n            $this->path = static::normalizePath($this->path);\n        }\n\n        if ($this->query) {\n            $this->query = static::normalizeQuery($this->query);\n        }\n\n        if ($this->fragment) {\n            $this->fragment = static::normalizeFragment($this->fragment);\n        }\n\n        \/\/ If path is empty (and we have a host), path should be '\/'\n        \/\/ Isn't this valid ONLY for HTTP-URI?\n        if ($this->host && empty($this->path)) {\n            $this->path = '\/';\n        }\n\n        return $this;\n    }\n\n    \/**\n     * Convert a relative URI into an absolute URI using a base absolute URI as\n     * a reference.\n     *\n     * This is similar to merge() - only it uses the supplied URI as the\n     * base reference instead of using the current URI as the base reference.\n     *\n     * Merging algorithm is adapted from RFC-3986 section 5.2\n     * (@link http:\/\/tools.ietf.org\/html\/rfc3986#section-5.2)\n     *\n     * @param  Uri|string $baseUri\n     * @throws Exception\\InvalidArgumentException\n     * @return Uri\n     *\/\n    public function resolve($baseUri)\n    {\n        \/\/ Ignore if URI is absolute\n        if ($this->isAbsolute()) {\n            return $this;\n        }\n\n        if (is_string($baseUri)) {\n            $baseUri = new static($baseUri);\n        } elseif (!$baseUri instanceof Uri) {\n            throw new Exception\\InvalidArgumentException(\n                'Provided base URI must be a string or a Uri object'\n            );\n        }\n\n        \/\/ Merging starts here...\n        if ($this->getHost()) {\n            $this->setPath(static::removePathDotSegments($this->getPath()));\n        } else {\n            $basePath = $baseUri->getPath();\n            $relPath  = $this->getPath();\n            if (!$relPath) {\n                $this->setPath($basePath);\n                if (!$this->getQuery()) {\n                    $this->setQuery($baseUri->getQuery());\n                }\n            } else {\n                if (substr($relPath, 0, 1) == '\/') {\n                    $this->setPath(static::removePathDotSegments($relPath));\n                } else {\n                    if ($baseUri->getHost() && !$basePath) {\n                        $mergedPath = '\/';\n                    } else {\n                        $mergedPath = substr($basePath, 0, strrpos($basePath, '\/') + 1);\n                    }\n                    $this->setPath(static::removePathDotSegments($mergedPath . $relPath));\n                }\n            }\n\n            \/\/ Set the authority part\n            $this->setUserInfo($baseUri->getUserInfo());\n            $this->setHost($baseUri->getHost());\n            $this->setPort($baseUri->getPort());\n        }\n\n        $this->setScheme($baseUri->getScheme());\n        return $this;\n    }\n\n    \/**\n     * Convert the link to a relative link by substracting a base URI\n     *\n     *  This is the opposite of resolving a relative link - i.e. creating a\n     *  relative reference link from an original URI and a base URI.\n     *\n     *  If the two URIs do not intersect (e.g. the original URI is not in any\n     *  way related to the base URI) the URI will not be modified.\n     *\n     * @param  Uri|string $baseUri\n     * @return Uri\n     *\/\n    public function makeRelative($baseUri)\n    {\n        \/\/ Copy base URI, we should not modify it\n        $baseUri = new static($baseUri);\n\n        $this->normalize();\n        $baseUri->normalize();\n\n        $host     = $this->getHost();\n        $baseHost = $baseUri->getHost();\n        if ($host && $baseHost && ($host != $baseHost)) {\n            \/\/ Not the same hostname\n            return $this;\n        }\n\n        $port     = $this->getPort();\n        $basePort = $baseUri->getPort();\n        if ($port && $basePort && ($port != $basePort)) {\n            \/\/ Not the same port\n            return $this;\n        }\n\n        $scheme     = $this->getScheme();\n        $baseScheme = $baseUri->getScheme();\n        if ($scheme && $baseScheme && ($scheme != $baseScheme)) {\n            \/\/ Not the same scheme (e.g. HTTP vs. HTTPS)\n            return $this;\n        }\n\n        \/\/ Remove host, port and scheme\n        $this->setHost(null)\n             ->setPort(null)\n             ->setScheme(null);\n\n        \/\/ Is path the same?\n        if ($this->getPath() == $baseUri->getPath()) {\n            $this->setPath('');\n            return $this;\n        }\n\n        $pathParts = preg_split('|(\/)|', $this->getPath(), null, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);\n        $baseParts = preg_split('|(\/)|', $baseUri->getPath(), null, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);\n\n        \/\/ Get the intersection of existing path parts and those from the\n        \/\/ provided URI\n        $matchingParts = array_intersect_assoc($pathParts, $baseParts);\n\n        \/\/ Loop through the matches\n        foreach ($matchingParts as $index => $segment) {\n            \/\/ If we skip an index at any point, we have parent traversal, and\n            \/\/ need to prepend the path accordingly\n            if ($index && !isset($matchingParts[$index - 1])) {\n                array_unshift($pathParts, '..\/');\n                continue;\n            }\n\n            \/\/ Otherwise, we simply unset the given path segment\n            unset($pathParts[$index]);\n        }\n\n        \/\/ Reset the path by imploding path segments\n        $this->setPath(implode($pathParts));\n\n        return $this;\n    }\n\n    \/**\n     * Get the scheme part of the URI\n     *\n     * @return string|null\n     *\/\n    public function getScheme()\n    {\n        return $this->scheme;\n    }\n\n    \/**\n     * Get the User-info (usually user:password) part\n     *\n     * @return string|null\n     *\/\n    public function getUserInfo()\n    {\n        return $this->userInfo;\n    }\n\n    \/**\n     * Get the URI host\n     *\n     * @return string|null\n     *\/\n    public function getHost()\n    {\n        return $this->host;\n    }\n\n    \/**\n     * Get the URI port\n     *\n     * @return int|null\n     *\/\n    public function getPort()\n    {\n        return $this->port;\n    }\n\n    \/**\n     * Get the URI path\n     *\n     * @return string|null\n     *\/\n    public function getPath()\n    {\n        return $this->path;\n    }\n\n    \/**\n     * Get the URI query\n     *\n     * @return string|null\n     *\/\n    public function getQuery()\n    {\n        return $this->query;\n    }\n\n    \/**\n     * Return the query string as an associative array of key => value pairs\n     *\n     * This is an extension to RFC-3986 but is quite useful when working with\n     * most common URI types\n     *\n     * @return array\n     *\/\n    public function getQueryAsArray()\n    {\n        $query = array();\n        if ($this->query) {\n            parse_str($this->query, $query);\n        }\n\n        return $query;\n    }\n\n    \/**\n     * Get the URI fragment\n     *\n     * @return string|null\n     *\/\n    public function getFragment()\n    {\n        return $this->fragment;\n    }\n\n    \/**\n     * Set the URI scheme\n     *\n     * If the scheme is not valid according to the generic scheme syntax or\n     * is not acceptable by the specific URI class (e.g. 'http' or 'https' are\n     * the only acceptable schemes for the Zend\\Uri\\Http class) an exception\n     * will be thrown.\n     *\n     * You can check if a scheme is valid before setting it using the\n     * validateScheme() method.\n     *\n     * @param  string $scheme\n     * @throws Exception\\InvalidUriPartException\n     * @return Uri\n     *\/\n    public function setScheme($scheme)\n    {\n        if (($scheme !== null) && (!self::validateScheme($scheme))) {\n            throw new Exception\\InvalidUriPartException(sprintf(\n                'Scheme \"%s\" is not valid or is not accepted by %s',\n                $scheme,\n                get_class($this)\n            ), Exception\\InvalidUriPartException::INVALID_SCHEME);\n        }\n\n        $this->scheme = $scheme;\n        return $this;\n    }\n\n    \/**\n     * Set the URI User-info part (usually user:password)\n     *\n     * @param  string $userInfo\n     * @return Uri\n     * @throws Exception\\InvalidUriPartException If the schema definition\n     * does not have this part\n     *\/\n    public function setUserInfo($userInfo)\n    {\n        $this->userInfo = $userInfo;\n        return $this;\n    }\n\n    \/**\n     * Set the URI host\n     *\n     * Note that the generic syntax for URIs allows using host names which\n     * are not necessarily IPv4 addresses or valid DNS host names. For example,\n     * IPv6 addresses are allowed as well, and also an abstract \"registered name\"\n     * which may be any name composed of a valid set of characters, including,\n     * for example, tilda (~) and underscore (_) which are not allowed in DNS\n     * names.\n     *\n     * Subclasses of Uri may impose more strict validation of host names - for\n     * example the HTTP RFC clearly states that only IPv4 and valid DNS names\n     * are allowed in HTTP URIs.\n     *\n     * @param  string $host\n     * @throws Exception\\InvalidUriPartException\n     * @return Uri\n     *\/\n    public function setHost($host)\n    {\n        if (($host !== '')\n            && ($host !== null)\n            && !self::validateHost($host, $this->validHostTypes)\n        ) {\n            throw new Exception\\InvalidUriPartException(sprintf(\n                'Host \"%s\" is not valid or is not accepted by %s',\n                $host,\n                get_class($this)\n            ), Exception\\InvalidUriPartException::INVALID_HOSTNAME);\n        }\n\n        $this->host = $host;\n        return $this;\n    }\n\n    \/**\n     * Set the port part of the URI\n     *\n     * @param  int $port\n     * @return Uri\n     *\/\n    public function setPort($port)\n    {\n        $this->port = $port;\n        return $this;\n    }\n\n    \/**\n     * Set the path\n     *\n     * @param  string $path\n     * @return Uri\n     *\/\n    public function setPath($path)\n    {\n        $this->path = $path;\n        return $this;\n    }\n\n    \/**\n     * Set the query string\n     *\n     * If an array is provided, will encode this array of parameters into a\n     * query string. Array values will be represented in the query string using\n     * PHP's common square bracket notation.\n     *\n     * @param  string|array $query\n     * @return Uri\n     *\/\n    public function setQuery($query)\n    {\n        if (is_array($query)) {\n            \/\/ We replace the + used for spaces by http_build_query with the\n            \/\/ more standard %20.\n            $query = str_replace('+', '%20', http_build_query($query));\n        }\n\n        $this->query = $query;\n        return $this;\n    }\n\n    \/**\n     * Set the URI fragment part\n     *\n     * @param  string $fragment\n     * @return Uri\n     * @throws Exception\\InvalidUriPartException If the schema definition\n     * does not have this part\n     *\/\n    public function setFragment($fragment)\n    {\n        $this->fragment = $fragment;\n        return $this;\n    }\n\n    \/**\n     * Magic method to convert the URI to a string\n     *\n     * @return string\n     *\/\n    public function __toString()\n    {\n        try {\n            return $this->toString();\n        } catch (\\Exception $e) {\n            return '';\n        }\n    }\n\n    \/**\n     * Encoding and Validation Methods\n     *\/\n\n    \/**\n     * Check if a scheme is valid or not\n     *\n     * Will check $scheme to be valid against the generic scheme syntax defined\n     * in RFC-3986. If the class also defines specific acceptable schemes, will\n     * also check that $scheme is one of them.\n     *\n     * @param  string $scheme\n     * @return bool\n     *\/\n    public static function validateScheme($scheme)\n    {\n        if (!empty(static::$validSchemes)\n            && !in_array(strtolower($scheme), static::$validSchemes)\n        ) {\n            return false;\n        }\n\n        return (bool) preg_match('\/^[A-Za-z][A-Za-z0-9\\-\\.+]*$\/', $scheme);\n    }\n\n    \/**\n     * Check that the userInfo part of a URI is valid\n     *\n     * @param  string $userInfo\n     * @return bool\n     *\/\n    public static function validateUserInfo($userInfo)\n    {\n        $regex = '\/^(?:[' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . ':]+|%[A-Fa-f0-9]{2})*$\/';\n        return (bool) preg_match($regex, $userInfo);\n    }\n\n    \/**\n     * Validate the host part\n     *\n     * Users may control which host types to allow by passing a second parameter\n     * with a bitmask of HOST_* constants which are allowed. If not specified,\n     * all address types will be allowed.\n     *\n     * Note that the generic URI syntax allows different host representations,\n     * including IPv4 addresses, IPv6 addresses and future IP address formats\n     * enclosed in square brackets, and registered names which may be DNS names\n     * or even more complex names. This is different (and is much more loose)\n     * from what is commonly accepted as valid HTTP URLs for example.\n     *\n     * @param  string  $host\n     * @param  int $allowed bitmask of allowed host types\n     * @return bool\n     *\/\n    public static function validateHost($host, $allowed = self::HOST_ALL)\n    {\n        \/*\n         * \"first-match-wins\" algorithm (RFC 3986):\n         * If host matches the rule for IPv4address, then it should be\n         * considered an IPv4 address literal and not a reg-name\n         *\/\n        if ($allowed & self::HOST_IPVANY) {\n            if (static::isValidIpAddress($host, $allowed)) {\n                return true;\n            }\n        }\n\n        if ($allowed & self::HOST_REGNAME) {\n            if (static::isValidRegName($host)) {\n                return true;\n            }\n        }\n\n        if ($allowed & self::HOST_DNS) {\n            if (static::isValidDnsHostname($host)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    \/**\n     * Validate the port\n     *\n     * Valid values include numbers between 1 and 65535, and empty values\n     *\n     * @param  int $port\n     * @return bool\n     *\/\n    public static function validatePort($port)\n    {\n        if ($port === 0) {\n            return false;\n        }\n\n        if ($port) {\n            $port = (int) $port;\n            if ($port < 1 || $port > 0xffff) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * Validate the path\n     *\n     * @param  string $path\n     * @return bool\n     *\/\n    public static function validatePath($path)\n    {\n        $pchar   = '(?:[' . self::CHAR_UNRESERVED . ':@&=\\+\\$,]+|%[A-Fa-f0-9]{2})*';\n        $segment = $pchar . \"(?:;{$pchar})*\";\n        $regex   = \"\/^{$segment}(?:\\\/{$segment})*$\/\";\n        return (bool) preg_match($regex, $path);\n    }\n\n    \/**\n     * Check if a URI query or fragment part is valid or not\n     *\n     * Query and Fragment parts are both restricted by the same syntax rules,\n     * so the same validation method can be used for both.\n     *\n     * You can encode a query or fragment part to ensure it is valid by passing\n     * it through the encodeQueryFragment() method.\n     *\n     * @param  string $input\n     * @return bool\n     *\/\n    public static function validateQueryFragment($input)\n    {\n        $regex = '\/^(?:[' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . ':@\\\/\\?]+|%[A-Fa-f0-9]{2})*$\/';\n        return (bool) preg_match($regex, $input);\n    }\n\n    \/**\n     * URL-encode the user info part of a URI\n     *\n     * @param  string $userInfo\n     * @return string\n     * @throws Exception\\InvalidArgumentException\n     *\/\n    public static function encodeUserInfo($userInfo)\n    {\n        if (!is_string($userInfo)) {\n            throw new Exception\\InvalidArgumentException(sprintf(\n                'Expecting a string, got %s',\n                (is_object($userInfo) ? get_class($userInfo) : gettype($userInfo))\n            ));\n        }\n\n        $regex   = '\/(?:[^' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . '%:]|%(?![A-Fa-f0-9]{2}))\/';\n        $escaper = static::getEscaper();\n        $replace = function ($match) use ($escaper) {\n            return $escaper->escapeUrl($match[0]);\n        };\n\n        return preg_replace_callback($regex, $replace, $userInfo);\n    }\n\n    \/**\n     * Encode the path\n     *\n     * Will replace all characters which are not strictly allowed in the path\n     * part with percent-encoded representation\n     *\n     * @param  string $path\n     * @throws Exception\\InvalidArgumentException\n     * @return string\n     *\/\n    public static function encodePath($path)\n    {\n        if (!is_string($path)) {\n            throw new Exception\\InvalidArgumentException(sprintf(\n                'Expecting a string, got %s',\n                (is_object($path) ? get_class($path) : gettype($path))\n            ));\n        }\n\n        $regex   = '\/(?:[^' . self::CHAR_UNRESERVED . ':@&=\\+\\$,\\\/;%]+|%(?![A-Fa-f0-9]{2}))\/';\n        $escaper = static::getEscaper();\n        $replace = function ($match) use ($escaper) {\n            return $escaper->escapeUrl($match[0]);\n        };\n\n        return preg_replace_callback($regex, $replace, $path);\n    }\n\n    \/**\n     * URL-encode a query string or fragment based on RFC-3986 guidelines.\n     *\n     * Note that query and fragment encoding allows more unencoded characters\n     * than the usual rawurlencode() function would usually return - for example\n     * '\/' and ':' are allowed as literals.\n     *\n     * @param  string $input\n     * @return string\n     * @throws Exception\\InvalidArgumentException\n     *\/\n    public static function encodeQueryFragment($input)\n    {\n        if (!is_string($input)) {\n            throw new Exception\\InvalidArgumentException(sprintf(\n                'Expecting a string, got %s',\n                (is_object($input) ? get_class($input) : gettype($input))\n            ));\n        }\n\n        $regex   = '\/(?:[^' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . '%:@\\\/\\?]+|%(?![A-Fa-f0-9]{2}))\/';\n        $escaper = static::getEscaper();\n        $replace = function ($match) use ($escaper) {\n            return $escaper->escapeUrl($match[0]);\n        };\n\n        return preg_replace_callback($regex, $replace, $input);\n    }\n\n    \/**\n     * Extract only the scheme part out of a URI string.\n     *\n     * This is used by the parse() method, but is useful as a standalone public\n     * method if one wants to test a URI string for it's scheme before doing\n     * anything with it.\n     *\n     * Will return the scheme if found, or NULL if no scheme found (URI may\n     * still be valid, but not full)\n     *\n     * @param  string $uriString\n     * @throws Exception\\InvalidArgumentException\n     * @return string|null\n     *\/\n    public static function parseScheme($uriString)\n    {\n        if (! is_string($uriString)) {\n            throw new Exception\\InvalidArgumentException(sprintf(\n                'Expecting a string, got %s',\n                (is_object($uriString) ? get_class($uriString) : gettype($uriString))\n            ));\n        }\n\n        if (preg_match('\/^([A-Za-z][A-Za-z0-9\\.\\+\\-]*):\/', $uriString, $match)) {\n            return $match[1];\n        }\n\n        return;\n    }\n\n    \/**\n     * Remove any extra dot segments (\/..\/, \/.\/) from a path\n     *\n     * Algorithm is adapted from RFC-3986 section 5.2.4\n     * (@link http:\/\/tools.ietf.org\/html\/rfc3986#section-5.2.4)\n     *\n     * @todo   consider optimizing\n     *\n     * @param  string $path\n     * @return string\n     *\/\n    public static function removePathDotSegments($path)\n    {\n        $output = '';\n\n        while ($path) {\n            if ($path == '..' || $path == '.') {\n                break;\n            }\n\n            switch (true) {\n                case ($path == '\/.'):\n                    $path = '\/';\n                    break;\n                case ($path == '\/..'):\n                    $path   = '\/';\n                    $lastSlashPos = strrpos($output, '\/', -1);\n                    if (false === $lastSlashPos) {\n                        break;\n                    }\n                    $output = substr($output, 0, $lastSlashPos);\n                    break;\n                case (substr($path, 0, 4) == '\/..\/'):\n                    $path   = '\/' . substr($path, 4);\n                    $lastSlashPos = strrpos($output, '\/', -1);\n                    if (false === $lastSlashPos) {\n                        break;\n                    }\n                    $output = substr($output, 0, $lastSlashPos);\n                    break;\n                case (substr($path, 0, 3) == '\/.\/'):\n                    $path = substr($path, 2);\n                    break;\n                case (substr($path, 0, 2) == '.\/'):\n                    $path = substr($path, 2);\n                    break;\n                case (substr($path, 0, 3) == '..\/'):\n                    $path = substr($path, 3);\n                    break;\n                default:\n                    $slash = strpos($path, '\/', 1);\n                    if ($slash === false) {\n                        $seg = $path;\n                    } else {\n                        $seg = substr($path, 0, $slash);\n                    }\n\n                    $output .= $seg;\n                    $path    = substr($path, strlen($seg));\n                    break;\n            }\n        }\n\n        return $output;\n    }\n\n    \/**\n     * Merge a base URI and a relative URI into a new URI object\n     *\n     * This convenience method wraps ::resolve() to allow users to quickly\n     * create new absolute URLs without the need to instantiate and clone\n     * URI objects.\n     *\n     * If objects are passed in, none of the passed objects will be modified.\n     *\n     * @param  Uri|string $baseUri\n     * @param  Uri|string $relativeUri\n     * @return Uri\n     *\/\n    public static function merge($baseUri, $relativeUri)\n    {\n        $uri = new static($relativeUri);\n        return $uri->resolve($baseUri);\n    }\n\n    \/**\n     * Check if a host name is a valid IP address, depending on allowed IP address types\n     *\n     * @param  string  $host\n     * @param  int $allowed allowed address types\n     * @return bool\n     *\/\n    protected static function isValidIpAddress($host, $allowed)\n    {\n        $validatorParams = array(\n            'allowipv4'      => (bool) ($allowed & self::HOST_IPV4),\n            'allowipv6'      => false,\n            'allowipvfuture' => false,\n            'allowliteral'   => false,\n        );\n\n        \/\/ Test only IPv4\n        $validator = new Validator\\Ip($validatorParams);\n        $return = $validator->isValid($host);\n        if ($return) {\n            return true;\n        }\n\n        \/\/ IPv6 & IPvLiteral must be in literal format\n        $validatorParams = array(\n            'allowipv4'      => false,\n            'allowipv6'      => (bool) ($allowed & self::HOST_IPV6),\n            'allowipvfuture' => (bool) ($allowed & self::HOST_IPVFUTURE),\n            'allowliteral'   => true,\n        );\n        static $regex = '\/^\\[.*\\]$\/';\n        $validator->setOptions($validatorParams);\n        return (preg_match($regex, $host) && $validator->isValid($host));\n    }\n\n    \/**\n     * Check if an address is a valid DNS hostname\n     *\n     * @param  string $host\n     * @return bool\n     *\/\n    protected static function isValidDnsHostname($host)\n    {\n        $validator = new Validator\\Hostname(array(\n            'allow' => Validator\\Hostname::ALLOW_DNS | Validator\\Hostname::ALLOW_LOCAL,\n        ));\n\n        return $validator->isValid($host);\n    }\n\n    \/**\n     * Check if an address is a valid registered name (as defined by RFC-3986) address\n     *\n     * @param  string $host\n     * @return bool\n     *\/\n    protected static function isValidRegName($host)\n    {\n        $regex = '\/^(?:[' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . ':@\\\/\\?]+|%[A-Fa-f0-9]{2})+$\/';\n        return (bool) preg_match($regex, $host);\n    }\n\n    \/**\n     * Part normalization methods\n     *\n     * These are called by normalize() using static::_normalize*() so they may\n     * be extended or overridden by extending classes to implement additional\n     * scheme specific normalization rules\n     *\/\n\n    \/**\n     * Normalize the scheme\n     *\n     * Usually this means simply converting the scheme to lower case\n     *\n     * @param  string $scheme\n     * @return string\n     *\/\n    protected static function normalizeScheme($scheme)\n    {\n        return strtolower($scheme);\n    }\n\n    \/**\n     * Normalize the host part\n     *\n     * By default this converts host names to lower case\n     *\n     * @param  string $host\n     * @return string\n     *\/\n    protected static function normalizeHost($host)\n    {\n        return strtolower($host);\n    }\n\n    \/**\n     * Normalize the port\n     *\n     * If the class defines a default port for the current scheme, and the\n     * current port is default, it will be unset.\n     *\n     * @param  int $port\n     * @param  string  $scheme\n     * @return int|null\n     *\/\n    protected static function normalizePort($port, $scheme = null)\n    {\n        if ($scheme\n            && isset(static::$defaultPorts[$scheme])\n            && ($port == static::$defaultPorts[$scheme])\n        ) {\n            return;\n        }\n\n        return $port;\n    }\n\n    \/**\n     * Normalize the path\n     *\n     * This involves removing redundant dot segments, decoding any over-encoded\n     * characters and encoding everything that needs to be encoded and is not\n     *\n     * @param  string $path\n     * @return string\n     *\/\n    protected static function normalizePath($path)\n    {\n        $path = self::encodePath(\n            self::decodeUrlEncodedChars(\n                self::removePathDotSegments($path),\n                '\/[' . self::CHAR_UNRESERVED . ':@&=\\+\\$,\\\/;%]\/'\n            )\n        );\n\n        return $path;\n    }\n\n    \/**\n     * Normalize the query part\n     *\n     * This involves decoding everything that doesn't need to be encoded, and\n     * encoding everything else\n     *\n     * @param  string $query\n     * @return string\n     *\/\n    protected static function normalizeQuery($query)\n    {\n        $query = self::encodeQueryFragment(\n            self::decodeUrlEncodedChars(\n                $query,\n                '\/[' . self::CHAR_UNRESERVED . self::CHAR_QUERY_DELIMS . ':@\\\/\\?]\/'\n            )\n        );\n\n        return $query;\n    }\n\n    \/**\n     * Normalize the fragment part\n     *\n     * Currently this is exactly the same as normalizeQuery().\n     *\n     * @param  string $fragment\n     * @return string\n     *\/\n    protected static function normalizeFragment($fragment)\n    {\n        $fragment = self::encodeQueryFragment(\n            self::decodeUrlEncodedChars(\n                $fragment,\n                '\/[' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . '%:@\\\/\\?]\/'\n            )\n        );\n\n        return $fragment;\n    }\n\n    \/**\n     * Decode all percent encoded characters which are allowed to be represented literally\n     *\n     * Will not decode any characters which are not listed in the 'allowed' list\n     *\n     * @param string $input\n     * @param string $allowed Pattern of allowed characters\n     * @return mixed\n     *\/\n    protected static function decodeUrlEncodedChars($input, $allowed = '')\n    {\n        $decodeCb = function ($match) use ($allowed) {\n            $char = rawurldecode($match[0]);\n            if (preg_match($allowed, $char)) {\n                return $char;\n            }\n            return strtoupper($match[0]);\n        };\n\n        return preg_replace_callback('\/%[A-Fa-f0-9]{2}\/', $decodeCb, $input);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,0,4,null,0,0,0,0,0,0,0,4,0,0,0,0,null,4,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,null,0,0,null,null,0,null,0,0,null,0,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,null,0,null,0,0,null,0,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,0,0,0,0,0,0,0,null,null,null,null,null,null,null,null,null,0,null,null,0,0,0,0,null,null,0,0,0,null,null,0,null,null,0,0,0,0,0,0,null,0,0,0,0,null,0,0,0,null,0,0,null,0,0,null,null,null,0,0,0,0,null,0,0,null,null,null,0,0,0,0,0,0,null,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,0,null,0,null,0,0,0,null,0,0,0,0,0,0,0,0,0,0,null,0,0,0,0,0,null,0,0,0,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,0,0,null,0,0,0,null,0,0,0,null,0,0,0,null,0,0,0,null,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,0,0,0,null,0,null,null,null,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,null,0,null,null,null,null,0,0,0,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,null,0,0,0,null,0,null,null,0,0,0,null,0,null,null,0,0,0,null,0,null,null,null,0,0,0,null,null,0,0,0,null,null,0,0,null,null,null,0,null,null,0,null,null,0,0,0,null,null,null,0,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,0,0,0,0,0,null,null,4,4,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,4,4,4,0,0,0,0,0,null,null,4,4,null,null,null,null,null,null,null,null,null,null,4,4,null,null,null,null,null,null,null,null,null,null,4,4,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,0,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,0,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,4,4,0,null,null,4,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,0,0,0,null,0,null,0,0,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,0,0,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,null,null,0,0,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,null,null,0,0,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,null,null,0,0,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,null,null,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,0,null,null,0,0,0,0,0,0,0,0,0,null,0,0,0,0,0,0,0,null,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,null,null,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,null,null,0,0,0,0,null,null,null,null,0,0,0,0,0,0,0,0,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,0,null,0,null,null]},{"name":"vendor\/zendframework\/zend-uri\/src\/UriInterface.php","source":"<?php\n\/**\n * Zend Framework (http:\/\/framework.zend.com\/)\n *\n * @link      http:\/\/github.com\/zendframework\/zf2 for the canonical source repository\n * @copyright Copyright (c) 2005-2015 Zend Technologies USA Inc. (http:\/\/www.zend.com)\n * @license   http:\/\/framework.zend.com\/license\/new-bsd New BSD License\n *\/\n\nnamespace Zend\\Uri;\n\n\/**\n * Interface defining a URI\n *\/\ninterface UriInterface\n{\n    \/**\n     * Create a new URI object\n     *\n     * @param  Uri|string|null $uri\n     * @throws Exception\\InvalidArgumentException\n     *\/\n    public function __construct($uri = null);\n\n    \/**\n     * Check if the URI is valid\n     *\n     * Note that a relative URI may still be valid\n     *\n     * @return bool\n     *\/\n    public function isValid();\n\n    \/**\n     * Check if the URI is a valid relative URI\n     *\n     * @return bool\n     *\/\n    public function isValidRelative();\n\n    \/**\n     * Check if the URI is an absolute or relative URI\n     *\n     * @return bool\n     *\/\n    public function isAbsolute();\n\n    \/**\n     * Parse a URI string\n     *\n     * @param  string $uri\n     * @return Uri\n     *\/\n    public function parse($uri);\n\n    \/**\n     * Compose the URI into a string\n     *\n     * @return string\n     * @throws Exception\\InvalidUriException\n     *\/\n    public function toString();\n\n    \/**\n     * Normalize the URI\n     *\n     * Normalizing a URI includes removing any redundant parent directory or\n     * current directory references from the path (e.g. foo\/bar\/..\/baz becomes\n     * foo\/baz), normalizing the scheme case, decoding any over-encoded\n     * characters etc.\n     *\n     * Eventually, two normalized URLs pointing to the same resource should be\n     * equal even if they were originally represented by two different strings\n     *\n     * @return Uri\n     *\/\n    public function normalize();\n\n    \/**\n     * Convert the link to a relative link by substracting a base URI\n     *\n     *  This is the opposite of resolving a relative link - i.e. creating a\n     *  relative reference link from an original URI and a base URI.\n     *\n     *  If the two URIs do not intersect (e.g. the original URI is not in any\n     *  way related to the base URI) the URI will not be modified.\n     *\n     * @param  Uri|string $baseUri\n     * @return Uri\n     *\/\n    public function makeRelative($baseUri);\n\n    \/**\n     * Get the scheme part of the URI\n     *\n     * @return string|null\n     *\/\n    public function getScheme();\n\n    \/**\n     * Get the User-info (usually user:password) part\n     *\n     * @return string|null\n     *\/\n    public function getUserInfo();\n\n    \/**\n     * Get the URI host\n     *\n     * @return string|null\n     *\/\n    public function getHost();\n\n    \/**\n     * Get the URI port\n     *\n     * @return int|null\n     *\/\n    public function getPort();\n\n    \/**\n     * Get the URI path\n     *\n     * @return string|null\n     *\/\n    public function getPath();\n\n    \/**\n     * Get the URI query\n     *\n     * @return string|null\n     *\/\n    public function getQuery();\n\n    \/**\n     * Return the query string as an associative array of key => value pairs\n     *\n     * This is an extension to RFC-3986 but is quite useful when working with\n     * most common URI types\n     *\n     * @return array\n     *\/\n    public function getQueryAsArray();\n\n    \/**\n     * Get the URI fragment\n     *\n     * @return string|null\n     *\/\n    public function getFragment();\n\n    \/**\n     * Set the URI scheme\n     *\n     * If the scheme is not valid according to the generic scheme syntax or\n     * is not acceptable by the specific URI class (e.g. 'http' or 'https' are\n     * the only acceptable schemes for the Zend\\Uri\\Http class) an exception\n     * will be thrown.\n     *\n     * You can check if a scheme is valid before setting it using the\n     * validateScheme() method.\n     *\n     * @param  string $scheme\n     * @throws Exception\\InvalidUriPartException\n     * @return Uri\n     *\/\n    public function setScheme($scheme);\n\n    \/**\n     * Set the URI User-info part (usually user:password)\n     *\n     * @param  string $userInfo\n     * @return Uri\n     * @throws Exception\\InvalidUriPartException If the schema definition\n     * does not have this part\n     *\/\n    public function setUserInfo($userInfo);\n\n    \/**\n     * Set the URI host\n     *\n     * Note that the generic syntax for URIs allows using host names which\n     * are not necessarily IPv4 addresses or valid DNS host names. For example,\n     * IPv6 addresses are allowed as well, and also an abstract \"registered name\"\n     * which may be any name composed of a valid set of characters, including,\n     * for example, tilda (~) and underscore (_) which are not allowed in DNS\n     * names.\n     *\n     * Subclasses of Uri may impose more strict validation of host names - for\n     * example the HTTP RFC clearly states that only IPv4 and valid DNS names\n     * are allowed in HTTP URIs.\n     *\n     * @param  string $host\n     * @throws Exception\\InvalidUriPartException\n     * @return Uri\n     *\/\n    public function setHost($host);\n\n    \/**\n     * Set the port part of the URI\n     *\n     * @param  int $port\n     * @return Uri\n     *\/\n    public function setPort($port);\n\n    \/**\n     * Set the path\n     *\n     * @param  string $path\n     * @return Uri\n     *\/\n    public function setPath($path);\n\n    \/**\n     * Set the query string\n     *\n     * If an array is provided, will encode this array of parameters into a\n     * query string. Array values will be represented in the query string using\n     * PHP's common square bracket notation.\n     *\n     * @param  string|array $query\n     * @return Uri\n     *\/\n    public function setQuery($query);\n\n    \/**\n     * Set the URI fragment part\n     *\n     * @param  string $fragment\n     * @return Uri\n     * @throws Exception\\InvalidUriPartException If the schema definition\n     * does not have this part\n     *\/\n    public function setFragment($fragment);\n\n    \/**\n     * Magic method to convert the URI to a string\n     *\n     * @return string\n     *\/\n    public function __toString();\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}]}